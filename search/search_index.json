{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"KayTrust Developer Space What is KayTrust? KayTrust is a complete digital identity solution comprised of: A set of technical specifications based on Internet standards Reference implementations: Libraries (currently for Java and Javascript/NodeJS) to make implementation of core KayTrust specs easier for developers. Ready-to-use software built on top of the libraries: KayTrust Wallet . A mobile Wallet for users (free of charge). KayTrust Provider . An enterprise server suite for organisations that wish to issue and manage credentials with minimal effort. The purpose of this space is to make life easy for developers. You will eventually find specifications, library references, tutorials and examples on how to use the core libraries, as well as manuals to install, configure, use and extend KayTrust Provider and KayTrust Wallet. Not all the documentation is available yet at this developer space is new, so please bear with us! KayTrust Stack What does Digital Identity mean? Identity refers to 2 things: Identifiers , i.e. unique and non-ambiguous strings used to refer to people, organizations, vehicles, building, etc. An email address, a phone number, a national ID number, a nickname or a physical address are all identifiers within a certain system. Claims , i.e. what is said about those entities. It's also usually important to consider who says those things. For example \"Individual with ID number 123 can drive\" is useless without the information (and proof) of who claims it \u2013 typically a government entity. A set of claims, packed along with an issuing entity's identifier and a way to verify the whole thing, is called a credential . The vision of decentralised digital identity It is important to understand the vision behind self-sovereign identity: nobody (no company, not any government, etc.) may control, block, censure, delete or spoof users' identity, restrict what users may do with their identity, or access information that users didn't agree to share. KayTrust achieves that by using a decentralised trust repository (typically a blockchain) for identifiers, for credential proofs, and for sharing consent. The repository itself only stores proofs of data integrity. No private information is stored on the shared repository, so KayTrust works on public repositories such as public blockchains. For more information, please visit kaytrust.id .","title":"Home"},{"location":"#kaytrust-developer-space","text":"","title":"KayTrust Developer Space"},{"location":"#what-is-kaytrust","text":"KayTrust is a complete digital identity solution comprised of: A set of technical specifications based on Internet standards Reference implementations: Libraries (currently for Java and Javascript/NodeJS) to make implementation of core KayTrust specs easier for developers. Ready-to-use software built on top of the libraries: KayTrust Wallet . A mobile Wallet for users (free of charge). KayTrust Provider . An enterprise server suite for organisations that wish to issue and manage credentials with minimal effort. The purpose of this space is to make life easy for developers. You will eventually find specifications, library references, tutorials and examples on how to use the core libraries, as well as manuals to install, configure, use and extend KayTrust Provider and KayTrust Wallet. Not all the documentation is available yet at this developer space is new, so please bear with us!","title":"What is KayTrust?"},{"location":"#kaytrust-stack","text":"","title":"KayTrust Stack"},{"location":"#what-does-digital-identity-mean","text":"Identity refers to 2 things: Identifiers , i.e. unique and non-ambiguous strings used to refer to people, organizations, vehicles, building, etc. An email address, a phone number, a national ID number, a nickname or a physical address are all identifiers within a certain system. Claims , i.e. what is said about those entities. It's also usually important to consider who says those things. For example \"Individual with ID number 123 can drive\" is useless without the information (and proof) of who claims it \u2013 typically a government entity. A set of claims, packed along with an issuing entity's identifier and a way to verify the whole thing, is called a credential .","title":"What does Digital Identity mean?"},{"location":"#the-vision-of-decentralised-digital-identity","text":"It is important to understand the vision behind self-sovereign identity: nobody (no company, not any government, etc.) may control, block, censure, delete or spoof users' identity, restrict what users may do with their identity, or access information that users didn't agree to share. KayTrust achieves that by using a decentralised trust repository (typically a blockchain) for identifiers, for credential proofs, and for sharing consent. The repository itself only stores proofs of data integrity. No private information is stored on the shared repository, so KayTrust works on public repositories such as public blockchains. For more information, please visit kaytrust.id .","title":"The vision of decentralised digital identity"},{"location":"Manuals/","text":"Identity Contracts Introduction This section is intended to guide you through all the functionalities offered by the Identity contracts. First, lets recap the types of contracts and how they are related and finally explore what we can do with them. Considerations In the current state contracts are available for ethereum networks. General assumptions Device: This document supposes a user/entity accessing the contract through any device like a computer, mobile phone, tablet, IoT device, remote server. Later in this document the term device refers to any of the mentioned here. User: The end user who creates its identity either through the IndetityManager or direclty by deploying an instance of the proxy smart contract. Types of contracts Two contracts are used in order to create and manage identities. Proxy contract The Proxy smart contract represents the Identity for a specific person . This contract Allows to: Set one or more ethereum addresses as the owner/owners of a proxy instance. Allows to forward any message to any other contract in the network where the proxy contract has been deployed. You are totally free to deploy a proxy contract instance without depending of any other contract. When it is done you can set an address as the owner of that contract. Another way to deploy a proxy instance is by using an Identity Manager contract. The identity manager is explained in the next section. Forward any message to any other contract. This is the main method in this contract. Interested to see all the details about the Proxy contract?. Please refer to the following documentation Identity Manager contract This contract is aimed to be used as a layer of abstraction when making actions related to your identity. Later in this document called IM. This contract is not owned or administered by anyone . Authorization levels in the Identity Manager Contract The following authorization levels are currently supported in the Identity Manager contract: Those levels can be applied to any device with a configured private key. fw: Allows the device to forward messages through the IdentityManager contract. auth: If assigned to a certain device you can create an offline logic that includes querying to the IM contract if the device has authentication capabilities; it allows developers perform authentication processes. devicemanager: Allows to add a new device from which the user can access to its identity. admin: A user with this capability is able to transfer its proxy identity to a new IdentityManager. Available actions in the Identity Manager Those actions can be categorized in three groups: Identity lifecycle thorugh the Identity manager Identity creation reference Register/remove devices to interact with their identities which live on the blockchain reference Transfer identity management to a new IdentityManager reference Identity recovery Administrative actions Add/Remove capabilities to a device reference Check capabilities a certain device is granted in the Identity Manager Contract. reference Forward messages through the IdentityManager: The identity Manager serves as a proxy to deliver messages to any existing contract in the netwwork when the Identity Manager contract lives. reference Identity Manager contract deployment The IdentityManager contract can have many flavours. In this version we use solidity in order to make it deployable on ethereum networks. As a developer who want to use the Kaytrust solution you don not need to deploy the IdentityManager contract , instead simply consume its methods though our available Kaytrust SDKs: Kaytrust Java SDK","title":"Manuals"},{"location":"Manuals/#identity-contracts","text":"","title":"Identity Contracts"},{"location":"Manuals/#introduction","text":"This section is intended to guide you through all the functionalities offered by the Identity contracts. First, lets recap the types of contracts and how they are related and finally explore what we can do with them.","title":"Introduction"},{"location":"Manuals/#considerations","text":"In the current state contracts are available for ethereum networks.","title":"Considerations"},{"location":"Manuals/#general-assumptions","text":"Device: This document supposes a user/entity accessing the contract through any device like a computer, mobile phone, tablet, IoT device, remote server. Later in this document the term device refers to any of the mentioned here. User: The end user who creates its identity either through the IndetityManager or direclty by deploying an instance of the proxy smart contract.","title":"General assumptions"},{"location":"Manuals/#types-of-contracts","text":"Two contracts are used in order to create and manage identities.","title":"Types of contracts"},{"location":"Manuals/#proxy-contract","text":"The Proxy smart contract represents the Identity for a specific person . This contract Allows to: Set one or more ethereum addresses as the owner/owners of a proxy instance. Allows to forward any message to any other contract in the network where the proxy contract has been deployed. You are totally free to deploy a proxy contract instance without depending of any other contract. When it is done you can set an address as the owner of that contract. Another way to deploy a proxy instance is by using an Identity Manager contract. The identity manager is explained in the next section. Forward any message to any other contract. This is the main method in this contract. Interested to see all the details about the Proxy contract?. Please refer to the following documentation","title":"Proxy contract"},{"location":"Manuals/#identity-manager-contract","text":"This contract is aimed to be used as a layer of abstraction when making actions related to your identity. Later in this document called IM. This contract is not owned or administered by anyone .","title":"Identity Manager contract"},{"location":"Manuals/#authorization-levels-in-the-identity-manager-contract","text":"The following authorization levels are currently supported in the Identity Manager contract: Those levels can be applied to any device with a configured private key. fw: Allows the device to forward messages through the IdentityManager contract. auth: If assigned to a certain device you can create an offline logic that includes querying to the IM contract if the device has authentication capabilities; it allows developers perform authentication processes. devicemanager: Allows to add a new device from which the user can access to its identity. admin: A user with this capability is able to transfer its proxy identity to a new IdentityManager.","title":"Authorization levels in the Identity Manager Contract"},{"location":"Manuals/#available-actions-in-the-identity-manager","text":"Those actions can be categorized in three groups: Identity lifecycle thorugh the Identity manager Identity creation reference Register/remove devices to interact with their identities which live on the blockchain reference Transfer identity management to a new IdentityManager reference Identity recovery Administrative actions Add/Remove capabilities to a device reference Check capabilities a certain device is granted in the Identity Manager Contract. reference Forward messages through the IdentityManager: The identity Manager serves as a proxy to deliver messages to any existing contract in the netwwork when the Identity Manager contract lives. reference","title":"Available actions in the Identity Manager"},{"location":"Manuals/#identity-manager-contract-deployment","text":"The IdentityManager contract can have many flavours. In this version we use solidity in order to make it deployable on ethereum networks. As a developer who want to use the Kaytrust solution you don not need to deploy the IdentityManager contract , instead simply consume its methods though our available Kaytrust SDKs: Kaytrust Java SDK","title":"Identity Manager contract deployment"},{"location":"Specs/","text":"KayTrust Specifications Why did you need to define anything? Websites , electronic mail (email), email addresses , TCP connections , IP addresses , URLs , HTML pages , JPEG . Those are known and mature concepts. Passwords , cryptographic keys , digital signatures , unique identifiers . Also mature concepts. Likes , tweets , cookies , browser-side scripts , user profiles. Those are a bit younger but also well known. Blockchain . Verifiable credentials . Digital identity . Now we're talking about something more recent in the history of internet. Those concepts are slowly taking shape, paving their way into users' and developers' minds, and into standards organizations' discussions. RFCs are being written, W3C Working Groups are being set up, blog articles are being cited. Since digital identity is both a young a wide domain, KayTrust's objective is to bind together the state of the art of digital identity standards and turn them into a usable package for people and for businesses. To the point, please. Fair enough. Core identity KayTrust uses the standard DID protocol for identifiers, and defines a \"gid\" DID method based on smart contracts . Specification Builds on top of What is it good for? \"gid\" DID method W3C's DID Specification Ethereum-based DIDs Proxy contract ERC Ethereum Transaction forwarding, on-chain representation, single Ethereum addresses Identity Manager ERC Ethereum Flexible controlling logic for Proxy contracts Verifiable credentials and Presentations Besides identifiers, the point of an identity is to have credentials associated to it. A credential answers the question \"Who are you?\" and contains one or more key-value claims (e.g. birth date, name, qualifications, citizenships, etc.) about an entity called subject, issued by another entity called issuer. The Verifiable Credentials Working Group at the W3C is defining a standard that KayTrust follows. Both Verifiable Credentials (VC) and Verifiable Presentations (VP) contain proofs, which is what makes them verifiable. The VC specification doesn't enforce a specific proof algorithm but describes the articulation between a credential/presentation and a specific proof method. Implementers are free to come up with their own proof method or to follow someone else's. The draft ERC (Ethereum Request for Comments) describes a way for any entity to attest arbitrary content on a smart contract. There is a corresponding proof type that enables to use that attestation registry inside a Verifiable Credential or a Verifiable Presentation. Specification Builds on top of What is it good for? Content Attestation Registry ERC Ethereum Attesting any kind of content on-chain Attestation Registry VC proof type W3C's Verifiable Credentials Specification Using a Content Attestation Registry as proof of a VC or a VP Real-world, self-sovereign authentication: \"DID Connect\" KayTrust introduces a way for identity owners (a.k.a. subjects) to authenticate on third-party apps. We propose using OpenID Connect, only in a self-sovereign fashion. The trick is to use as Authorization Server the identity owner's own device, as opposed to a predefined AS in traditional services. Specification Builds on top of What is it good for? DIDConnect OIDC Profile OpenID Connect Self-sovereign use of OpenID Connect Schemas KayTrust mostly relies on well-known schemas, such as the great work done by the schema.org community. However, when the need arises, additional schemas are defined. Schema Purpose Trusted Credentials Chain of Trust for Verifiable Credentials","title":"Specs"},{"location":"Specs/#kaytrust-specifications","text":"","title":"KayTrust Specifications"},{"location":"Specs/#why-did-you-need-to-define-anything","text":"Websites , electronic mail (email), email addresses , TCP connections , IP addresses , URLs , HTML pages , JPEG . Those are known and mature concepts. Passwords , cryptographic keys , digital signatures , unique identifiers . Also mature concepts. Likes , tweets , cookies , browser-side scripts , user profiles. Those are a bit younger but also well known. Blockchain . Verifiable credentials . Digital identity . Now we're talking about something more recent in the history of internet. Those concepts are slowly taking shape, paving their way into users' and developers' minds, and into standards organizations' discussions. RFCs are being written, W3C Working Groups are being set up, blog articles are being cited. Since digital identity is both a young a wide domain, KayTrust's objective is to bind together the state of the art of digital identity standards and turn them into a usable package for people and for businesses.","title":"Why did you need to define anything?"},{"location":"Specs/#to-the-point-please","text":"Fair enough.","title":"To the point, please."},{"location":"Specs/#core-identity","text":"KayTrust uses the standard DID protocol for identifiers, and defines a \"gid\" DID method based on smart contracts . Specification Builds on top of What is it good for? \"gid\" DID method W3C's DID Specification Ethereum-based DIDs Proxy contract ERC Ethereum Transaction forwarding, on-chain representation, single Ethereum addresses Identity Manager ERC Ethereum Flexible controlling logic for Proxy contracts","title":"Core identity"},{"location":"Specs/#verifiable-credentials-and-presentations","text":"Besides identifiers, the point of an identity is to have credentials associated to it. A credential answers the question \"Who are you?\" and contains one or more key-value claims (e.g. birth date, name, qualifications, citizenships, etc.) about an entity called subject, issued by another entity called issuer. The Verifiable Credentials Working Group at the W3C is defining a standard that KayTrust follows. Both Verifiable Credentials (VC) and Verifiable Presentations (VP) contain proofs, which is what makes them verifiable. The VC specification doesn't enforce a specific proof algorithm but describes the articulation between a credential/presentation and a specific proof method. Implementers are free to come up with their own proof method or to follow someone else's. The draft ERC (Ethereum Request for Comments) describes a way for any entity to attest arbitrary content on a smart contract. There is a corresponding proof type that enables to use that attestation registry inside a Verifiable Credential or a Verifiable Presentation. Specification Builds on top of What is it good for? Content Attestation Registry ERC Ethereum Attesting any kind of content on-chain Attestation Registry VC proof type W3C's Verifiable Credentials Specification Using a Content Attestation Registry as proof of a VC or a VP","title":"Verifiable credentials and Presentations"},{"location":"Specs/#real-world-self-sovereign-authentication-did-connect","text":"KayTrust introduces a way for identity owners (a.k.a. subjects) to authenticate on third-party apps. We propose using OpenID Connect, only in a self-sovereign fashion. The trick is to use as Authorization Server the identity owner's own device, as opposed to a predefined AS in traditional services. Specification Builds on top of What is it good for? DIDConnect OIDC Profile OpenID Connect Self-sovereign use of OpenID Connect","title":"Real-world, self-sovereign authentication: \"DID Connect\""},{"location":"Specs/#schemas","text":"KayTrust mostly relies on well-known schemas, such as the great work done by the schema.org community. However, when the need arises, additional schemas are defined. Schema Purpose Trusted Credentials Chain of Trust for Verifiable Credentials","title":"Schemas"},{"location":"Tutorials/","text":"Tutorials About this section In this section, you will be able to find tutorials to help you use KayTrust As a DApp developer (WIP) As a backend developer Java SDK","title":"Tutorials"},{"location":"Tutorials/#tutorials","text":"","title":"Tutorials"},{"location":"Tutorials/#about-this-section","text":"In this section, you will be able to find tutorials to help you use KayTrust As a DApp developer (WIP) As a backend developer Java SDK","title":"About this section"},{"location":"about/","text":"Componentes For full documentation visit mkdocs.org . Protocolos mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. SDK Java mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. SDK JS mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. KayTrust Hub mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. KayTrust Provider mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. KayTrust Wallet mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Componentes"},{"location":"about/#componentes","text":"For full documentation visit mkdocs.org .","title":"Componentes"},{"location":"about/#protocolos","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Protocolos"},{"location":"about/#sdk-java","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"SDK Java"},{"location":"about/#sdk-js","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"SDK JS"},{"location":"about/#kaytrust-hub","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"KayTrust Hub"},{"location":"about/#kaytrust-provider","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"KayTrust Provider"},{"location":"about/#kaytrust-wallet","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"KayTrust Wallet"},{"location":"download/","text":"Donwloads KayTrust Wallet ...... Version Estable Version 12.0.4 Disponible en la PlayStore de Android Disponible en la MarketPlace de IOS Releases Version 12.0.1 Version 10.0.1","title":"Donwloads"},{"location":"download/#donwloads","text":"KayTrust Wallet ......","title":"Donwloads"},{"location":"download/#version-estable","text":"Version 12.0.4 Disponible en la PlayStore de Android Disponible en la MarketPlace de IOS","title":"Version Estable"},{"location":"download/#releases","text":"Version 12.0.1 Version 10.0.1","title":"Releases"},{"location":"join/","text":"Unete Para unirte a la comunidad mas grande de la Region ingresa al siguiente link kaytrust.id . Training Virtual In construction .. Eventos In construction .. Conferencias In construction .. Noticias In construction ..","title":"Unete"},{"location":"join/#unete","text":"Para unirte a la comunidad mas grande de la Region ingresa al siguiente link kaytrust.id .","title":"Unete"},{"location":"join/#training-virtual","text":"In construction ..","title":"Training Virtual"},{"location":"join/#eventos","text":"In construction ..","title":"Eventos"},{"location":"join/#conferencias","text":"In construction ..","title":"Conferencias"},{"location":"join/#noticias","text":"In construction ..","title":"Noticias"},{"location":"products/","text":"Productos El activo KayTrust cuenta con los siguientes productos: Protocolos de Identidad Identidad Digital SDK Hub SDK Provider KayTrust Hub KayTrust Provider KayTrust Wallet Protocolos de Identidad Proxy Contract .... Proxy Type .... Identidad Digital KayTrust Digital Identity - Proveedor de Identidad Digital .......... .......... Digital Identity - Dependencias Usando MAVEN <dependency> <groupId>com.everis.blockchain</groupId> <artifactId>algorithm</artifactId> <version>0.0.4</version> </dependency> O descargandote las librerias de la siguiente URL : [AzureRepos.id](https://azurerepos.id/). Digital Identity - Clases * Crear Credenciales ... .. * Crear Contrato * .... Digital Identity - Demo Crear Credenciales * Importar librerias package demo.acme.kaytrust import com.everis.blockchain.algorithm.web3j.html.Account; import com.everis.blockchain.algorithm.web3j.html.EthCore; import com.everis.blockchain.algorithm.web3j.html.EthCoreParams; public class GeneratePrivateKey { private static final Logger log = LoggerFactory.getLogger(\"GeneratePrivateKey\"); public void create() throws Exception { Account account = ethCore.createCredentials(\"\"); log.info(\"PRIVATE_KEY_BACKEND : \" + account.getPrivateKey()); log.info(\"ADDRESS_ETHEREUM_BACKEND : \" + account.getAddress()); } } SDK Hub In construction .. SDK Provider In construction .. KayTrust Hub In construction .. KayTrust Provider In construction .. KayTrust Wallet In construction ..","title":"Productos"},{"location":"products/#productos","text":"El activo KayTrust cuenta con los siguientes productos: Protocolos de Identidad Identidad Digital SDK Hub SDK Provider KayTrust Hub KayTrust Provider KayTrust Wallet","title":"Productos"},{"location":"products/#protocolos-de-identidad","text":"Proxy Contract .... Proxy Type ....","title":"Protocolos de Identidad"},{"location":"products/#identidad-digital","text":"KayTrust Digital Identity - Proveedor de Identidad Digital .......... .......... Digital Identity - Dependencias Usando MAVEN <dependency> <groupId>com.everis.blockchain</groupId> <artifactId>algorithm</artifactId> <version>0.0.4</version> </dependency> O descargandote las librerias de la siguiente URL : [AzureRepos.id](https://azurerepos.id/). Digital Identity - Clases * Crear Credenciales ... .. * Crear Contrato * .... Digital Identity - Demo Crear Credenciales * Importar librerias package demo.acme.kaytrust import com.everis.blockchain.algorithm.web3j.html.Account; import com.everis.blockchain.algorithm.web3j.html.EthCore; import com.everis.blockchain.algorithm.web3j.html.EthCoreParams; public class GeneratePrivateKey { private static final Logger log = LoggerFactory.getLogger(\"GeneratePrivateKey\"); public void create() throws Exception { Account account = ethCore.createCredentials(\"\"); log.info(\"PRIVATE_KEY_BACKEND : \" + account.getPrivateKey()); log.info(\"ADDRESS_ETHEREUM_BACKEND : \" + account.getAddress()); } }","title":"Identidad Digital"},{"location":"products/#sdk-hub","text":"In construction ..","title":"SDK Hub"},{"location":"products/#sdk-provider","text":"In construction ..","title":"SDK Provider"},{"location":"products/#kaytrust-hub","text":"In construction ..","title":"KayTrust Hub"},{"location":"products/#kaytrust-provider","text":"In construction ..","title":"KayTrust Provider"},{"location":"products/#kaytrust-wallet","text":"In construction ..","title":"KayTrust Wallet"},{"location":"Manuals/IM/IM_recover_identity/","text":"Recover your identity Lets imagine the situation where you no longer can access your device(s). In such scenario you can still recover your identity. In order to perform this process you can set a trusted third party with an \"devicemanager\" capability. In case of \"disaster\" scenarios you can contact the third party which after an offline check process can set a new device(\"newdevice\") through the \"adding a new device process\" explained above; after that you can access your already blockchain existing identity with your \"newdevice\". As a product Kaytrust (a trusted third party) has a set of tools that can help you benefit of the user friendly interfaces to guide you in this process.","title":"Recover your identity"},{"location":"Manuals/IM/IM_recover_identity/#recover-your-identity","text":"Lets imagine the situation where you no longer can access your device(s). In such scenario you can still recover your identity. In order to perform this process you can set a trusted third party with an \"devicemanager\" capability. In case of \"disaster\" scenarios you can contact the third party which after an offline check process can set a new device(\"newdevice\") through the \"adding a new device process\" explained above; after that you can access your already blockchain existing identity with your \"newdevice\". As a product Kaytrust (a trusted third party) has a set of tools that can help you benefit of the user friendly interfaces to guide you in this process.","title":"Recover your identity"},{"location":"Manuals/diagrams/administration/IM_identity_administration/","text":"Administrative capabilities Adding/removing capabilities to an existing device Adding/removing capabilities to an exiting device follows the exact process as adding a new device. Check user device permissions level Checking user's device permission level is as simple as executing a call to the \"hasCap\" method in the Identity Manager that administers your proxy contract.","title":"Administrative capabilities"},{"location":"Manuals/diagrams/administration/IM_identity_administration/#administrative-capabilities","text":"","title":"Administrative capabilities"},{"location":"Manuals/diagrams/administration/IM_identity_administration/#addingremoving-capabilities-to-an-existing-device","text":"Adding/removing capabilities to an exiting device follows the exact process as adding a new device.","title":"Adding/removing capabilities to an existing device"},{"location":"Manuals/diagrams/administration/IM_identity_administration/#check-user-device-permissions-level","text":"Checking user's device permission level is as simple as executing a call to the \"hasCap\" method in the Identity Manager that administers your proxy contract.","title":"Check user device permissions level"},{"location":"Manuals/diagrams/forward/forward/","text":"Forwarding though the IdentityManager Through the IdentityManager contract(AcmeIdentityManager) you are also able to forward transactions to any other contract, for that when you invoke AcmeIdentityManager to forward transactions it will make some verifications and then pass this message to your proxy contract (JhonProxy) which will make some verifications before reaching the desired contract. To clarify this, lets see a diagram to illustrate this flow:","title":"Forwarding though the IdentityManager"},{"location":"Manuals/diagrams/forward/forward/#forwarding-though-the-identitymanager","text":"Through the IdentityManager contract(AcmeIdentityManager) you are also able to forward transactions to any other contract, for that when you invoke AcmeIdentityManager to forward transactions it will make some verifications and then pass this message to your proxy contract (JhonProxy) which will make some verifications before reaching the desired contract. To clarify this, lets see a diagram to illustrate this flow:","title":"Forwarding though the IdentityManager"},{"location":"Manuals/diagrams/identity-lifecycle/IM_add_remove_device/","text":"Adding another device Lets assume John wants to add another device (JohnDeviceB) from which he can control his identity operations. Adding such device is as simple as giving it the desired capability(forward, device manager, admin or proxy). The next diagram shows what is the flow to achieve that: As shown in the prevous diagram, a new device has been added on behalf of John. Only \"deviceManager\" granted roles can authorize other devices. Because \"device B\" has \"deviceManager\" capability then it can grant any authorization level on behalf of John. Removing a device is similar to the adding process. The difference lies in the argument time, that is set a time less than the current time. For more information please check the setCap method in the IdentityManager contract.","title":"Adding another device"},{"location":"Manuals/diagrams/identity-lifecycle/IM_add_remove_device/#adding-another-device","text":"Lets assume John wants to add another device (JohnDeviceB) from which he can control his identity operations. Adding such device is as simple as giving it the desired capability(forward, device manager, admin or proxy). The next diagram shows what is the flow to achieve that: As shown in the prevous diagram, a new device has been added on behalf of John. Only \"deviceManager\" granted roles can authorize other devices. Because \"device B\" has \"deviceManager\" capability then it can grant any authorization level on behalf of John. Removing a device is similar to the adding process. The difference lies in the argument time, that is set a time less than the current time. For more information please check the setCap method in the IdentityManager contract.","title":"Adding another device"},{"location":"Manuals/diagrams/identity-lifecycle/IM_identity_creation/","text":"Creating an identity for a user through the IdentityManager Contract Assumptions: In order to show how to interact with the IdentityManager contract assume an already deployed instance of that and lets call it AcmeIdentityManager. Now thorugh this contract many users can deploy their identities. Lets say John have a device (JohnDeviceA), he wants to create his identity and register a device in order to use it to execute actions related to his identity. Lets see what is the flow to do that. At the end John has created a Proxy contract (JhonProxy). ProxyA represents John's identity. So from now, all actions performed by John through its device (JohnDeviceA) will be executed through JohnProxy. Note how the identity manager facilitates this process by setting up all what is needed an simply returning the proxy contract address to John. When setting the first device (JohnDeviceA) it has all the capabilities. Now John can access its JhonProxy identity through AcmeIdentityManager.","title":"Creating an identity for a user through the IdentityManager Contract"},{"location":"Manuals/diagrams/identity-lifecycle/IM_identity_creation/#creating-an-identity-for-a-user-through-the-identitymanager-contract","text":"Assumptions: In order to show how to interact with the IdentityManager contract assume an already deployed instance of that and lets call it AcmeIdentityManager. Now thorugh this contract many users can deploy their identities. Lets say John have a device (JohnDeviceA), he wants to create his identity and register a device in order to use it to execute actions related to his identity. Lets see what is the flow to do that. At the end John has created a Proxy contract (JhonProxy). ProxyA represents John's identity. So from now, all actions performed by John through its device (JohnDeviceA) will be executed through JohnProxy. Note how the identity manager facilitates this process by setting up all what is needed an simply returning the proxy contract address to John. When setting the first device (JohnDeviceA) it has all the capabilities. Now John can access its JhonProxy identity through AcmeIdentityManager.","title":"Creating an identity for a user through the IdentityManager Contract"},{"location":"Manuals/diagrams/identity-lifecycle/IM_migration_to_new_IM/","text":"Migrating to a new IdentityManager Lets imagine the situation when users want to migrate to a new IdentityManager, such scenario is totally feasible. In order to exemplify this, assume John as an identity that was created using Acme Identity Manager contract but something happened and he decides to migrate to a new Identity Manager contract lets name this CorpIM. The following diagram shows the logical flow when a new IdentityManager replaces an old one. As shown in the prevous diagram, a new IdentityManager (CorpIM) has replaced an old one (AcmeIM) It is worth to say that only devices with the ADMINISTRATOR capability, can perform this action.","title":"Migrating to a new IdentityManager"},{"location":"Manuals/diagrams/identity-lifecycle/IM_migration_to_new_IM/#migrating-to-a-new-identitymanager","text":"Lets imagine the situation when users want to migrate to a new IdentityManager, such scenario is totally feasible. In order to exemplify this, assume John as an identity that was created using Acme Identity Manager contract but something happened and he decides to migrate to a new Identity Manager contract lets name this CorpIM. The following diagram shows the logical flow when a new IdentityManager replaces an old one. As shown in the prevous diagram, a new IdentityManager (CorpIM) has replaced an old one (AcmeIM) It is worth to say that only devices with the ADMINISTRATOR capability, can perform this action.","title":"Migrating to a new IdentityManager"},{"location":"Specs/Content-Attestation-Registry-ERC/","text":"eip: <to be assigned> title: ERC: Content Attestation Registry author: David Ammouial (@davux) <dammouia@everis.com> discussions-to: <URL> status: Draft type: Standards Track category: ERC created: 2019-03-29 Simple Summary A generic and privacy-aware registry of attested information. Abstract This ERC describes a way for any entity to express and record its agreement with a given content, independently from the type of content, by storing a hash on chain along with a validity time range. Even though the existence of the agreement itself is provable and non-ambiguous, this specification doesn't place any semantics on the type of original content, how it's hashed, or what it means to agree with it. Likewise, it doesn't define any recommendation on the semantic validity of an attestation in relation to its recorded time range. As with any kind of recorded agreement, it is generally a good idea for the involved parties to ensure a mutual understanding on what is agreed upon and to what extent. This ERC also allows the agreeing party to amend a previously recorded attestation by redefining the validity time range (including retracting the attestation altogether). Motivation Traditionally, attesting to some kind of content is done through static signatures, e.g. a base64-encoded embedded RSA signature or a PGP signature. As for the smart contract world, hashes are often used in functions to certify content approval but no stable interface has been defined. This EIP is an attempt to homogenize a common interface for agreement that interoperable contract-based and web-based applications may start benefitting from. Also, traditional signatures, in order to be retracted or amended, need to be put in context of Certificate Revocation Lists (CRLs) or similar mechanisms. This EIP attempts to leverage blockchain technology to remove the need for such centralized databases. Definitions Attester The attester of a given content is any entity, represented by an Ethereum address, that records its agreement with that content. Attestation In this specification, an attestation is defined as a (start time, end time) tuple that represents the time range during which a content is agreed upon by a specific attester. Verifier The verifier of an attestation is an entity going through the process of reading an attestation for a given content and making conclusions on whether to trust that content. Specification The general idea of this EIP is that attesting a given content is equivalent to attesting a hash of that content, as long as the hashing function is known by the attester and the verifier. An attestation is recorded as an (iat, exp) tuple, where iat (\"issued at\") is the time the attestation starts to be valid, and exp (\"expires\") is the time after which the attestation is no longer valid. Note the special meaning of the following values: iat == 0 means the attester is NOT currently attesting to that content. In this case, the value of exp is irrelevant. Per Solidity rules, this is the initial value for any attestation. Its intended usage inside the attest() function is to explicitly revoke an existing (i.e. non-zero iat ) attestation. exp == 0 means the attester is not currently placing any expiration time on the attestation. Just like any other value, a value of 0 may be amended later if the attester decides so. This EIP defines the following functions: attest Used in a transaction to record an (iat, exp) attestation of a given hash. function attest(bytes32 hash, uint iat, uint exp) public; attestations Used to read the most recent attestation, if any, of a given hash , recorded by a given attester . Its return value is an (iat, exp) tuple. function attestations(bytes32 hash, address attester) public; This EIP defines the following event: Verified This event is emitted everytime a hash is attested or revoked by an attester and contains the iat and exp times of the attestation. A value of 0 for iat means any previous attestation is being revoked. The event may be emitted with any values for iat and exp , including values equal to the previous ones (for example an already revoked attestation may be revoked again, or an attestation may be attested again with the same values). event Verified(bytes32 indexed hash, address attester, uint iat, uint exp); Note about validity times The validity time range is a mere indication by the attester. This EIP does not define what policy should be applied by verifying software or people with respect to current time. Here are a few real-life policy examples: Safe policy . Some verifiers might decide that an attestation is only acceptable if the expiration time is at least 6 months in the future. Flexible policy . Some verifiers might leave a tolerance window during which they still accept an expired attestation. Strict policy . Some verifiers might only accept an attestation during the attestation time range. Some verifiers might apply more complex policies, e.g. where the tolerance depends on the identity of the attester, on the content, on the actual transaction time of the attestation, on the existence of previous attestations, etc. Rationale Storing validity times on-chain vs. off-chain Information stored on a blockchain is both public and permanent, which makes it a crucial decision to decide what to store and what not to store. For this reason, a balance should always be seeked between privacy and usefulness. Specifically, the decision to include validity times on chain rather than in the original content is a result of that subjective balance: Including validity times means leaking out information allowing to suspect or discard specific contents for a given hash. For example, time ranges of 3 weeks might give up certain types of documents, and exclude e.g. passports. Leaving validity times off-chain (typically in the original document) might not work very well for some types of documents where the issuer and the attester are separate entities and the attester doesn't have the liberty to emit an \"attestation document\" containing validity times. This specification allows verifiers to store date information on-chain. However, the attester and the verifier are always free to use any non-zero value in the (iat, exp) tuple and maintain date information off-chain instead. Attesting hashes vs. plain data To follow best practices, it was deemed equally secure, cheaper, and most respectful to privacy to record fixed-length bytes32 data rather than actual content. Backwards Compatibility This EIP doesn't introduce any known backwards compatibility issues. Implementation An implementation may be found here . Copyright Copyright and related rights waived via CC0 .","title":"Content Attestation Registry ERC"},{"location":"Specs/Content-Attestation-Registry-ERC/#simple-summary","text":"A generic and privacy-aware registry of attested information.","title":"Simple Summary"},{"location":"Specs/Content-Attestation-Registry-ERC/#abstract","text":"This ERC describes a way for any entity to express and record its agreement with a given content, independently from the type of content, by storing a hash on chain along with a validity time range. Even though the existence of the agreement itself is provable and non-ambiguous, this specification doesn't place any semantics on the type of original content, how it's hashed, or what it means to agree with it. Likewise, it doesn't define any recommendation on the semantic validity of an attestation in relation to its recorded time range. As with any kind of recorded agreement, it is generally a good idea for the involved parties to ensure a mutual understanding on what is agreed upon and to what extent. This ERC also allows the agreeing party to amend a previously recorded attestation by redefining the validity time range (including retracting the attestation altogether).","title":"Abstract"},{"location":"Specs/Content-Attestation-Registry-ERC/#motivation","text":"Traditionally, attesting to some kind of content is done through static signatures, e.g. a base64-encoded embedded RSA signature or a PGP signature. As for the smart contract world, hashes are often used in functions to certify content approval but no stable interface has been defined. This EIP is an attempt to homogenize a common interface for agreement that interoperable contract-based and web-based applications may start benefitting from. Also, traditional signatures, in order to be retracted or amended, need to be put in context of Certificate Revocation Lists (CRLs) or similar mechanisms. This EIP attempts to leverage blockchain technology to remove the need for such centralized databases.","title":"Motivation"},{"location":"Specs/Content-Attestation-Registry-ERC/#definitions","text":"Attester The attester of a given content is any entity, represented by an Ethereum address, that records its agreement with that content. Attestation In this specification, an attestation is defined as a (start time, end time) tuple that represents the time range during which a content is agreed upon by a specific attester. Verifier The verifier of an attestation is an entity going through the process of reading an attestation for a given content and making conclusions on whether to trust that content.","title":"Definitions"},{"location":"Specs/Content-Attestation-Registry-ERC/#specification","text":"The general idea of this EIP is that attesting a given content is equivalent to attesting a hash of that content, as long as the hashing function is known by the attester and the verifier. An attestation is recorded as an (iat, exp) tuple, where iat (\"issued at\") is the time the attestation starts to be valid, and exp (\"expires\") is the time after which the attestation is no longer valid. Note the special meaning of the following values: iat == 0 means the attester is NOT currently attesting to that content. In this case, the value of exp is irrelevant. Per Solidity rules, this is the initial value for any attestation. Its intended usage inside the attest() function is to explicitly revoke an existing (i.e. non-zero iat ) attestation. exp == 0 means the attester is not currently placing any expiration time on the attestation. Just like any other value, a value of 0 may be amended later if the attester decides so. This EIP defines the following functions: attest Used in a transaction to record an (iat, exp) attestation of a given hash. function attest(bytes32 hash, uint iat, uint exp) public; attestations Used to read the most recent attestation, if any, of a given hash , recorded by a given attester . Its return value is an (iat, exp) tuple. function attestations(bytes32 hash, address attester) public; This EIP defines the following event: Verified This event is emitted everytime a hash is attested or revoked by an attester and contains the iat and exp times of the attestation. A value of 0 for iat means any previous attestation is being revoked. The event may be emitted with any values for iat and exp , including values equal to the previous ones (for example an already revoked attestation may be revoked again, or an attestation may be attested again with the same values). event Verified(bytes32 indexed hash, address attester, uint iat, uint exp);","title":"Specification"},{"location":"Specs/Content-Attestation-Registry-ERC/#note-about-validity-times","text":"The validity time range is a mere indication by the attester. This EIP does not define what policy should be applied by verifying software or people with respect to current time. Here are a few real-life policy examples: Safe policy . Some verifiers might decide that an attestation is only acceptable if the expiration time is at least 6 months in the future. Flexible policy . Some verifiers might leave a tolerance window during which they still accept an expired attestation. Strict policy . Some verifiers might only accept an attestation during the attestation time range. Some verifiers might apply more complex policies, e.g. where the tolerance depends on the identity of the attester, on the content, on the actual transaction time of the attestation, on the existence of previous attestations, etc.","title":"Note about validity times"},{"location":"Specs/Content-Attestation-Registry-ERC/#rationale","text":"","title":"Rationale"},{"location":"Specs/Content-Attestation-Registry-ERC/#storing-validity-times-on-chain-vs-off-chain","text":"Information stored on a blockchain is both public and permanent, which makes it a crucial decision to decide what to store and what not to store. For this reason, a balance should always be seeked between privacy and usefulness. Specifically, the decision to include validity times on chain rather than in the original content is a result of that subjective balance: Including validity times means leaking out information allowing to suspect or discard specific contents for a given hash. For example, time ranges of 3 weeks might give up certain types of documents, and exclude e.g. passports. Leaving validity times off-chain (typically in the original document) might not work very well for some types of documents where the issuer and the attester are separate entities and the attester doesn't have the liberty to emit an \"attestation document\" containing validity times. This specification allows verifiers to store date information on-chain. However, the attester and the verifier are always free to use any non-zero value in the (iat, exp) tuple and maintain date information off-chain instead.","title":"Storing validity times on-chain vs. off-chain"},{"location":"Specs/Content-Attestation-Registry-ERC/#attesting-hashes-vs-plain-data","text":"To follow best practices, it was deemed equally secure, cheaper, and most respectful to privacy to record fixed-length bytes32 data rather than actual content.","title":"Attesting hashes vs. plain data"},{"location":"Specs/Content-Attestation-Registry-ERC/#backwards-compatibility","text":"This EIP doesn't introduce any known backwards compatibility issues.","title":"Backwards Compatibility"},{"location":"Specs/Content-Attestation-Registry-ERC/#implementation","text":"An implementation may be found here .","title":"Implementation"},{"location":"Specs/Content-Attestation-Registry-ERC/#copyright","text":"Copyright and related rights waived via CC0 .","title":"Copyright"},{"location":"Specs/DIDConnect/","text":"OpenID Connect Profile for self-sovereign identity (DIDConnect) Introduction This document explains how to authenticate a user against their self-sovereign identity. This method uses OpenID Connect (OIDC) , which itself builds upon the OAuth 2.0 framework . DID Connect uses OIDC in a way that enables Self-Sovereign Identity (SSI) and favours decentralization, by combining it with DIDs and, optionally, Verifiable Credentials. That makes it different from traditional provider-centric flows in a few aspects, as detailed below. Aspect Provider-Centric Identity Self-Sovereign Identity Authorization request URIs Use the Identity Provider (IdP)'s hostname Use didconnect: scheme. Authorization Server Identity Provider (IdP), known before when creating the request. Selected dynamically by user. Examples: user's own identity wallet, or a web application. Subject ID Assigned by IdP. User's DID. Client registration flow Client registers against IdP (must be authorized by IdP). Client ID is an opaque string. No authorization needed by a central entity for acting as a client. Client exposes a Verifiable Presentation, containing Verifiable Credentials issued by relevant authorities. Client ID is the URL of that presentation. Userinfo endpoint Managed by IdP. Endpoint URL is either static or discovered through OIDC Discovery. Provided dynamically: endpoint URL is present in id_token (\"userinfo\" claim). Public key for id_token's signature by client Either static or discovered through OIDC Discovery. Provided by DID Document (DDO). Client's whitelisted redirect_uri endpoints Registered and checked by the IdP. Announced as a claim in the Client ID's Verifiable Presentation. General flow The OIDC specification defines the following general flow: The clients registers (only once). The client presents an authentication request in the form of a didconnect://auth?... URI. The Authorization Server authenticates the user (for example, if the AS is a mobile app, the user should unlock the app) and obtains their consent. Depending on the grant flow, the Authorization Server generates a combination of identity token, grant code, and/or access token, then provides them to the client's redirect_uri contained in the request, according to the response_mode parameter (form, post or fragment). The client receives the tokens and/or code. If a code was received, the client gets the URL of the token endpoint from the token_uri parameter contained in the response and uses it to get the id_token and/or access_token. If an id_token was provided, the client verifies the user's identity from it. If a userinfo claim was present in the id_token, the client extracts the userinfo endpoint URL from it and queries it, providing the access token for authentication. The response is a verifiable presentation held by the user. Steps for the DIDConnect profile are detailed in the next sections. 1. Client registration Create a DID for your application. Obtain Verifiable Credentials that come from issuers the users will trust. The credentials may be self-issued if the users trust your application's DID. The credentials should typically claim information about your DID, such as the application's name, originating organization, logo, website, etc. Issue an additional Verifiable Credential containing the claim \"redirect_uri\" with the value of your application's whitelisted callback URL(s). That credential can be issued by your application's DID. Create a Verifiable Presentation containing those credentials and held by your app's DID. Place the Verifiable Presentation somewhere your users will be able to access it. The presentation's URL is your application's client ID. 2. Authentication request An authentication request is a URL of the following form: didconnect://auth?... with the following query parameters. Parameter Status Description client_id Required The URL of the client Verifiable Presentation. redirect_uri Required The callback URI the user should call after the AS generated the identity token. This URI will receive the token as a HTTP Bearer token (recommended) or as a query parameter. state Optional An opaque string defined by the client. That string will be provided as-is to the callback URI, as a query parameter also named state , allowing the client to link the response to the original request. response_type Optional Depends on the grant flow. Each flow is described by a combination of id_token , token , code , as defined by OIDC. response_mode Optional How the AS must issue the tokens. Must be one of query , fragment , form_post . 3. Obtaining user consent from AS When a user's Authorization Server receives a request from the application's client_id, it must treat client_id as an URL and fetch the Verifiable Presentation (VP) from it. Then, the AS must check the following conditions: The VP is valid and current. The redirect_uri value from the request matches one of the values present in the VP's credentials. Only valid and current credentials must be used. Then, the AS should request user's consent after showing the user all relevant claims, based on valid and current credential from the VP. Invalid or expired credentials should be ignored. 4. Token generation See OpenID Connect specification. 5. Getting the tokens and/or authorization code See OpenID Connect specification. 6. Accessing the tokens (if applicable) See OpenID Connect specification. TODO: Describe how token endpoint is read dynamically from response. 7. Verification of user's identity The endpoint listening on redirect_uri receives the following query parameters (as query parameters, HTML fragment or form post depending on the requested response mode): Parameter Status Description id_token Required A JSON Web Token (JWT) containing the user's DID. state Optional The original state from the authentication request, if any. access_token Optional A Bearer token authorizing access to information about the user The JWT contained in the id_token provides the following claims: Parameter Description sub The user's DID. iss The public key of the user's device. The JWT is only valid if the device is authorised for that DID and if the JWT is correctly signed by that public key. aud The requester's DID. The JWT is only valid if that value matches the value of client_id in the request. state The state present in the request, to avoid replay attacks. iat The date the JWT was issued at. You should check the JWT is not too old, otherwise it might be insecure. exp The date until which the JWT is valid. You should check that the JWT is not expired, otherwise it might be insecure. at_hash The hash of the access_token . c_hash The hash of the code . userinfo The URL of the Resource Server where a user's Verifiable Presentation is available. To properly verify the user's identity, the client must: Verify the signature of id_token JWT against the public key present as iss . Make sure the JWT's issuer is an authorized key of the JWT's subject (i.e. the user's DID), by matching it against the DID Document. Note for KayTrust Currently, KayTrust's \"GID\" DID method does not support DID Documents. Until it does, the steps to validate a public key are the following: Compute the user's Proxy address from the DID Call proxy.owner() to get the Identity Manager's address, or use a well-known Identity Manager address for legacy DIDs. Call im.hasCap(proxy, device, \"auth\") and verify the result is true . To support Levels of Assurance, replace \"auth\" with the expected Level of Assurance. 8. Accessing the user's protected resources (when applicable) If an access token was provided, the client can access user's information by querying the URL referenced as userinfo in the id_token, and provide the access token as an Authorization header, as described in OpenID Connect specification . The response is a Verifiable Presentation. The presentation's holder must be the user's authenticated DID. The presentation contains a proof attribute that allows the client to verify the holder's consent before using the included credentials. Examples of AS Examples of Authorization Servers implementations include: Mobile or desktop applications. Registration to the didconnect: scheme is specific to the operating system. Web applications. Registration to the didconnect: scheme is done using registerProtocolHandler() on the web browser. Limitations and possible improvements Flow support uncertainty This specification describes the use of a custom URI scheme to express authorization requests. This makes it possible for any registered software on the user agent to handle requests. This approach, similar to that of the mailto: and tel: URI schemes, implies the client app does not know what AS will actually respond to authorization requests, and what grant flows it will support. This uncertainty represents both a risk and added out-of-band work on the client side to try to guess what flow to request. One approach is to determine the type of AS based on heuristics. Another approach is to present multiple requests and let the user or the user agent make a decision. A possible improvement (see Appendix below) would be for a negotiation mechanism to be defined, where the client would announce the flows it supports, and let the AS make a decision based on its own capabilities. This would be similar to content type or language negotiation in HTTP. Appendix: Ideas around Authorization Server diversity and flow negotiation This appendix describes a method for an OAuth client to dynamically negotiate with the AS the OAuth grant flow to be used, similar to content type or language negotiation in HTTP. This is useful in situations where the client can't know the flows that will be supported by the AS. One such example is a DIDConnect flow. The negotiation is in two steps: The client announces in the authorization request the grant flows it supports, as a semicolon-separated list of supported response types. The AS selects a grant flow according on its own capabilities. TODO: Details and examples.","title":"OpenID Connect Profile for self-sovereign identity (DIDConnect)"},{"location":"Specs/DIDConnect/#openid-connect-profile-for-self-sovereign-identity-didconnect","text":"","title":"OpenID Connect Profile for self-sovereign identity (DIDConnect)"},{"location":"Specs/DIDConnect/#introduction","text":"This document explains how to authenticate a user against their self-sovereign identity. This method uses OpenID Connect (OIDC) , which itself builds upon the OAuth 2.0 framework . DID Connect uses OIDC in a way that enables Self-Sovereign Identity (SSI) and favours decentralization, by combining it with DIDs and, optionally, Verifiable Credentials. That makes it different from traditional provider-centric flows in a few aspects, as detailed below. Aspect Provider-Centric Identity Self-Sovereign Identity Authorization request URIs Use the Identity Provider (IdP)'s hostname Use didconnect: scheme. Authorization Server Identity Provider (IdP), known before when creating the request. Selected dynamically by user. Examples: user's own identity wallet, or a web application. Subject ID Assigned by IdP. User's DID. Client registration flow Client registers against IdP (must be authorized by IdP). Client ID is an opaque string. No authorization needed by a central entity for acting as a client. Client exposes a Verifiable Presentation, containing Verifiable Credentials issued by relevant authorities. Client ID is the URL of that presentation. Userinfo endpoint Managed by IdP. Endpoint URL is either static or discovered through OIDC Discovery. Provided dynamically: endpoint URL is present in id_token (\"userinfo\" claim). Public key for id_token's signature by client Either static or discovered through OIDC Discovery. Provided by DID Document (DDO). Client's whitelisted redirect_uri endpoints Registered and checked by the IdP. Announced as a claim in the Client ID's Verifiable Presentation.","title":"Introduction"},{"location":"Specs/DIDConnect/#general-flow","text":"The OIDC specification defines the following general flow: The clients registers (only once). The client presents an authentication request in the form of a didconnect://auth?... URI. The Authorization Server authenticates the user (for example, if the AS is a mobile app, the user should unlock the app) and obtains their consent. Depending on the grant flow, the Authorization Server generates a combination of identity token, grant code, and/or access token, then provides them to the client's redirect_uri contained in the request, according to the response_mode parameter (form, post or fragment). The client receives the tokens and/or code. If a code was received, the client gets the URL of the token endpoint from the token_uri parameter contained in the response and uses it to get the id_token and/or access_token. If an id_token was provided, the client verifies the user's identity from it. If a userinfo claim was present in the id_token, the client extracts the userinfo endpoint URL from it and queries it, providing the access token for authentication. The response is a verifiable presentation held by the user. Steps for the DIDConnect profile are detailed in the next sections.","title":"General flow"},{"location":"Specs/DIDConnect/#1-client-registration","text":"Create a DID for your application. Obtain Verifiable Credentials that come from issuers the users will trust. The credentials may be self-issued if the users trust your application's DID. The credentials should typically claim information about your DID, such as the application's name, originating organization, logo, website, etc. Issue an additional Verifiable Credential containing the claim \"redirect_uri\" with the value of your application's whitelisted callback URL(s). That credential can be issued by your application's DID. Create a Verifiable Presentation containing those credentials and held by your app's DID. Place the Verifiable Presentation somewhere your users will be able to access it. The presentation's URL is your application's client ID.","title":"1. Client registration"},{"location":"Specs/DIDConnect/#2-authentication-request","text":"An authentication request is a URL of the following form: didconnect://auth?... with the following query parameters. Parameter Status Description client_id Required The URL of the client Verifiable Presentation. redirect_uri Required The callback URI the user should call after the AS generated the identity token. This URI will receive the token as a HTTP Bearer token (recommended) or as a query parameter. state Optional An opaque string defined by the client. That string will be provided as-is to the callback URI, as a query parameter also named state , allowing the client to link the response to the original request. response_type Optional Depends on the grant flow. Each flow is described by a combination of id_token , token , code , as defined by OIDC. response_mode Optional How the AS must issue the tokens. Must be one of query , fragment , form_post .","title":"2. Authentication request"},{"location":"Specs/DIDConnect/#3-obtaining-user-consent-from-as","text":"When a user's Authorization Server receives a request from the application's client_id, it must treat client_id as an URL and fetch the Verifiable Presentation (VP) from it. Then, the AS must check the following conditions: The VP is valid and current. The redirect_uri value from the request matches one of the values present in the VP's credentials. Only valid and current credentials must be used. Then, the AS should request user's consent after showing the user all relevant claims, based on valid and current credential from the VP. Invalid or expired credentials should be ignored.","title":"3. Obtaining user consent from AS"},{"location":"Specs/DIDConnect/#4-token-generation","text":"See OpenID Connect specification.","title":"4. Token generation"},{"location":"Specs/DIDConnect/#5-getting-the-tokens-andor-authorization-code","text":"See OpenID Connect specification.","title":"5. Getting the tokens and/or authorization code"},{"location":"Specs/DIDConnect/#6-accessing-the-tokens-if-applicable","text":"See OpenID Connect specification. TODO: Describe how token endpoint is read dynamically from response.","title":"6. Accessing the tokens (if applicable)"},{"location":"Specs/DIDConnect/#7-verification-of-users-identity","text":"The endpoint listening on redirect_uri receives the following query parameters (as query parameters, HTML fragment or form post depending on the requested response mode): Parameter Status Description id_token Required A JSON Web Token (JWT) containing the user's DID. state Optional The original state from the authentication request, if any. access_token Optional A Bearer token authorizing access to information about the user The JWT contained in the id_token provides the following claims: Parameter Description sub The user's DID. iss The public key of the user's device. The JWT is only valid if the device is authorised for that DID and if the JWT is correctly signed by that public key. aud The requester's DID. The JWT is only valid if that value matches the value of client_id in the request. state The state present in the request, to avoid replay attacks. iat The date the JWT was issued at. You should check the JWT is not too old, otherwise it might be insecure. exp The date until which the JWT is valid. You should check that the JWT is not expired, otherwise it might be insecure. at_hash The hash of the access_token . c_hash The hash of the code . userinfo The URL of the Resource Server where a user's Verifiable Presentation is available. To properly verify the user's identity, the client must: Verify the signature of id_token JWT against the public key present as iss . Make sure the JWT's issuer is an authorized key of the JWT's subject (i.e. the user's DID), by matching it against the DID Document.","title":"7. Verification of user's identity"},{"location":"Specs/DIDConnect/#note-for-kaytrust","text":"Currently, KayTrust's \"GID\" DID method does not support DID Documents. Until it does, the steps to validate a public key are the following: Compute the user's Proxy address from the DID Call proxy.owner() to get the Identity Manager's address, or use a well-known Identity Manager address for legacy DIDs. Call im.hasCap(proxy, device, \"auth\") and verify the result is true . To support Levels of Assurance, replace \"auth\" with the expected Level of Assurance.","title":"Note for KayTrust"},{"location":"Specs/DIDConnect/#8-accessing-the-users-protected-resources-when-applicable","text":"If an access token was provided, the client can access user's information by querying the URL referenced as userinfo in the id_token, and provide the access token as an Authorization header, as described in OpenID Connect specification . The response is a Verifiable Presentation. The presentation's holder must be the user's authenticated DID. The presentation contains a proof attribute that allows the client to verify the holder's consent before using the included credentials.","title":"8. Accessing the user's protected resources (when applicable)"},{"location":"Specs/DIDConnect/#examples-of-as","text":"Examples of Authorization Servers implementations include: Mobile or desktop applications. Registration to the didconnect: scheme is specific to the operating system. Web applications. Registration to the didconnect: scheme is done using registerProtocolHandler() on the web browser.","title":"Examples of AS"},{"location":"Specs/DIDConnect/#limitations-and-possible-improvements","text":"","title":"Limitations and possible improvements"},{"location":"Specs/DIDConnect/#flow-support-uncertainty","text":"This specification describes the use of a custom URI scheme to express authorization requests. This makes it possible for any registered software on the user agent to handle requests. This approach, similar to that of the mailto: and tel: URI schemes, implies the client app does not know what AS will actually respond to authorization requests, and what grant flows it will support. This uncertainty represents both a risk and added out-of-band work on the client side to try to guess what flow to request. One approach is to determine the type of AS based on heuristics. Another approach is to present multiple requests and let the user or the user agent make a decision. A possible improvement (see Appendix below) would be for a negotiation mechanism to be defined, where the client would announce the flows it supports, and let the AS make a decision based on its own capabilities. This would be similar to content type or language negotiation in HTTP.","title":"Flow support uncertainty"},{"location":"Specs/DIDConnect/#appendix-ideas-around-authorization-server-diversity-and-flow-negotiation","text":"This appendix describes a method for an OAuth client to dynamically negotiate with the AS the OAuth grant flow to be used, similar to content type or language negotiation in HTTP. This is useful in situations where the client can't know the flows that will be supported by the AS. One such example is a DIDConnect flow. The negotiation is in two steps: The client announces in the authorization request the grant flows it supports, as a semicolon-separated list of supported response types. The AS selects a grant flow according on its own capabilities. TODO: Details and examples.","title":"Appendix: Ideas around Authorization Server diversity and flow negotiation"},{"location":"Specs/Ethereum-Attestation-Registry-Proof-Type/","text":"Ethereum Attestation Registry Proof Type Abstract This document introduces a new embedded proof type for Verifiable Credentials and Verifiable Presentations, as described in Verifiable Credentials Data Model 's \"Proofs\" section , currently published by the W3C Credentials Community Group. Status of this Document This specification is an unofficial draft. It is provided as a reference for people and organisations who wish to implement Ethereum-based proofs. Introduction The Verifiable Credentials specification describes a modular mechanism for declaring how a given credential must be verified. This specification introduces a new type of proof called \"EthereumAttestationRegistry2019\". This type of proof is based on a trusted smart contract deployed on an Ethereum blockchain accessible by the verifier. Verification of a credential containing this type of proof is done by calls a specific function to the smart contract. This document extends the Verifiable Credentials specification and assumes that the terminology and concepts of that specification are known. Specification An \"Ethereum attestation registry (2019)\" proof is represented by an object contained in the \"proof\" section of a Verifiable Credential. As such, it is considered an \"embedded proof\". It must contain the following attributes: type The proof type, as defined in the Verifiable Credentials specification. The value MUST be `\"EthereumAttestationRegistry2019\"`. contractAddress A string containing the hexadecimal Ethereum address of the smart contract that allows the verification of the credential. For example: `\"0x123f681646d4a755815f9cb19e1acc8565a0c2ac\"`. That contract must implement **EIP-XXX (to be defined): Content Attestation Registry**. networkId A string containing the hexadecimal NetworkId of the Ethereum network where the contract is deployed. In order to be able to verify the credential, the verifier must have read access to a node running on that network. For a proof to be valid, it MUST be possible to determine an Ethereum address from the \"issuer\" attribute. For example, the \"ev\" DID method allows to determine the Ethereum address from a DID. Example The following example shows a Verifiable Credential with an Ethereum Attestation Registry proof. { \"@type\": \"VerifiableCredential\", \"@context\": \"https://schema.org\", \"credentialSubject\": { \"@id\": \"did:example:abcd\", \"name\": \"John Doe\", \"birthdate\": \"2018-01-01\" }, \"issuer\": \"did:ev:2uukHPBYMjdZPkg4p5ZjipKHzkaXLr4T5ut\", \"proof\": { \"type\": \"EthereumAttestationRegistry2019\", \"contractAddress\": \"0x123f681646d4a755815f9cb19e1acc8565a0c2ac\", \"networkId\": \"0x19\" } } Proof Generation Method The following steps MUST be applied by a credential's issuer in order to generate an Ethereum Attestation Registry proof of the credential: Create the proof object as defined in previous sections and add it to the credential as a proof attribute. If proof already exists, ensure it becomes an array containing previous values + the new object. At this point, the issuer MAY distribute the credential. However, it won't be possible to verify the proof until the rest of the steps are applied, so it is RECOMMENDED to wait until the end of the proof generation to distribute the credential. Compute the credential's hash: Temporarily strip the whole \"proof\" attribute from the credential, even if it contains multiple proofs. Serialize the resulting object as a string. TODO: Describe the serialization method (it must be deterministic). Compute the SHA256 hash of the string. Determine the Ethereum address corresponding to the issuer's URI. Decide on the validity timerange of the attestation in the form of a integer couple (iat, exp) , where iat is the start date and exp is the expiration date. Decide on the Ethereum network and smart contract to be used for storing the attestation. Send a transaction to the Ethereum network and smart contract containing a call to the attest(bytes32 hash, uint iat, uint exp) function, where hash , iat and exp are the values computed above. Keep and distribute the resulting credential. Proof Revocation Method This proof type allows for an already-emitted credential to be revoked by its original issuer. The following steps MUST be applied by the credential's issuer in order to revoke an Ethereum Attestation Registry proof: Compute the credential's hash: Temporarily strip the whole \"proof\" attribute from the credential, even if it contains multiple proofs. Serialize the resulting object as a string. TODO: Describe the serialization method (it must be deterministic). Compute the SHA256 hash of the string. Determine the Ethereum address corresponding to the issuer's URI. Send a transaction to the Ethereum network and smart contract listed in the proof to be revoked, containing a call to the attest(bytes32 hash, 0, 0) function, where hash is the credential's hash. Note that no further action is required, since the attestation registry will be updated as soon as the transaction goes through. The attestation registry will also notify interested parties through an Ethereum event that the proof is no longer valid. Proof Verification Method The following steps MUST be applied by a credential's verifier in order to verify an Ethereum Attestation Registry proof of the credential: Compute the credential's hash: Temporarily strip the whole \"proof\" attribute from the credential, even if it contains multiple proofs. Serialize the resulting object as a string. TODO: Describe the serialization method (it must be deterministic). Compute the SHA256 hash of the string. Determine the Ethereum address corresponding to the issuer's URI. Call the attestations(hash, issuer) function of the smart contract listed in the proof, where hash is the credential's hash and issuer is issuer's Ethereum address and store the returned value couple as (iat, exp) . Those are the start date and end date, respectively, specified by the issuer when signing the credential. Verify that the time range is acceptable. The following two conditions below SHOULD both be verified for the credential to be considered valid. However, the verifier MAY apply a different policy if the use case justifies it. iat is not 0 and is lower than the time of the verification. exp is 0 or is higher than the time of the verification. Performance Considerations With this proof type, an Ethereum transaction must be executed for each new attestation. This specification should be improved in the future to allow more scalable approaches.","title":"Ethereum Attestation Registry Proof Type"},{"location":"Specs/Ethereum-Attestation-Registry-Proof-Type/#ethereum-attestation-registry-proof-type","text":"","title":"Ethereum Attestation Registry Proof Type"},{"location":"Specs/Ethereum-Attestation-Registry-Proof-Type/#abstract","text":"This document introduces a new embedded proof type for Verifiable Credentials and Verifiable Presentations, as described in Verifiable Credentials Data Model 's \"Proofs\" section , currently published by the W3C Credentials Community Group.","title":"Abstract"},{"location":"Specs/Ethereum-Attestation-Registry-Proof-Type/#status-of-this-document","text":"This specification is an unofficial draft. It is provided as a reference for people and organisations who wish to implement Ethereum-based proofs.","title":"Status of this Document"},{"location":"Specs/Ethereum-Attestation-Registry-Proof-Type/#introduction","text":"The Verifiable Credentials specification describes a modular mechanism for declaring how a given credential must be verified. This specification introduces a new type of proof called \"EthereumAttestationRegistry2019\". This type of proof is based on a trusted smart contract deployed on an Ethereum blockchain accessible by the verifier. Verification of a credential containing this type of proof is done by calls a specific function to the smart contract. This document extends the Verifiable Credentials specification and assumes that the terminology and concepts of that specification are known.","title":"Introduction"},{"location":"Specs/Ethereum-Attestation-Registry-Proof-Type/#specification","text":"An \"Ethereum attestation registry (2019)\" proof is represented by an object contained in the \"proof\" section of a Verifiable Credential. As such, it is considered an \"embedded proof\". It must contain the following attributes: type The proof type, as defined in the Verifiable Credentials specification. The value MUST be `\"EthereumAttestationRegistry2019\"`. contractAddress A string containing the hexadecimal Ethereum address of the smart contract that allows the verification of the credential. For example: `\"0x123f681646d4a755815f9cb19e1acc8565a0c2ac\"`. That contract must implement **EIP-XXX (to be defined): Content Attestation Registry**. networkId A string containing the hexadecimal NetworkId of the Ethereum network where the contract is deployed. In order to be able to verify the credential, the verifier must have read access to a node running on that network. For a proof to be valid, it MUST be possible to determine an Ethereum address from the \"issuer\" attribute. For example, the \"ev\" DID method allows to determine the Ethereum address from a DID.","title":"Specification"},{"location":"Specs/Ethereum-Attestation-Registry-Proof-Type/#example","text":"The following example shows a Verifiable Credential with an Ethereum Attestation Registry proof. { \"@type\": \"VerifiableCredential\", \"@context\": \"https://schema.org\", \"credentialSubject\": { \"@id\": \"did:example:abcd\", \"name\": \"John Doe\", \"birthdate\": \"2018-01-01\" }, \"issuer\": \"did:ev:2uukHPBYMjdZPkg4p5ZjipKHzkaXLr4T5ut\", \"proof\": { \"type\": \"EthereumAttestationRegistry2019\", \"contractAddress\": \"0x123f681646d4a755815f9cb19e1acc8565a0c2ac\", \"networkId\": \"0x19\" } }","title":"Example"},{"location":"Specs/Ethereum-Attestation-Registry-Proof-Type/#proof-generation-method","text":"The following steps MUST be applied by a credential's issuer in order to generate an Ethereum Attestation Registry proof of the credential: Create the proof object as defined in previous sections and add it to the credential as a proof attribute. If proof already exists, ensure it becomes an array containing previous values + the new object. At this point, the issuer MAY distribute the credential. However, it won't be possible to verify the proof until the rest of the steps are applied, so it is RECOMMENDED to wait until the end of the proof generation to distribute the credential. Compute the credential's hash: Temporarily strip the whole \"proof\" attribute from the credential, even if it contains multiple proofs. Serialize the resulting object as a string. TODO: Describe the serialization method (it must be deterministic). Compute the SHA256 hash of the string. Determine the Ethereum address corresponding to the issuer's URI. Decide on the validity timerange of the attestation in the form of a integer couple (iat, exp) , where iat is the start date and exp is the expiration date. Decide on the Ethereum network and smart contract to be used for storing the attestation. Send a transaction to the Ethereum network and smart contract containing a call to the attest(bytes32 hash, uint iat, uint exp) function, where hash , iat and exp are the values computed above. Keep and distribute the resulting credential.","title":"Proof Generation Method"},{"location":"Specs/Ethereum-Attestation-Registry-Proof-Type/#proof-revocation-method","text":"This proof type allows for an already-emitted credential to be revoked by its original issuer. The following steps MUST be applied by the credential's issuer in order to revoke an Ethereum Attestation Registry proof: Compute the credential's hash: Temporarily strip the whole \"proof\" attribute from the credential, even if it contains multiple proofs. Serialize the resulting object as a string. TODO: Describe the serialization method (it must be deterministic). Compute the SHA256 hash of the string. Determine the Ethereum address corresponding to the issuer's URI. Send a transaction to the Ethereum network and smart contract listed in the proof to be revoked, containing a call to the attest(bytes32 hash, 0, 0) function, where hash is the credential's hash. Note that no further action is required, since the attestation registry will be updated as soon as the transaction goes through. The attestation registry will also notify interested parties through an Ethereum event that the proof is no longer valid.","title":"Proof Revocation Method"},{"location":"Specs/Ethereum-Attestation-Registry-Proof-Type/#proof-verification-method","text":"The following steps MUST be applied by a credential's verifier in order to verify an Ethereum Attestation Registry proof of the credential: Compute the credential's hash: Temporarily strip the whole \"proof\" attribute from the credential, even if it contains multiple proofs. Serialize the resulting object as a string. TODO: Describe the serialization method (it must be deterministic). Compute the SHA256 hash of the string. Determine the Ethereum address corresponding to the issuer's URI. Call the attestations(hash, issuer) function of the smart contract listed in the proof, where hash is the credential's hash and issuer is issuer's Ethereum address and store the returned value couple as (iat, exp) . Those are the start date and end date, respectively, specified by the issuer when signing the credential. Verify that the time range is acceptable. The following two conditions below SHOULD both be verified for the credential to be considered valid. However, the verifier MAY apply a different policy if the use case justifies it. iat is not 0 and is lower than the time of the verification. exp is 0 or is higher than the time of the verification.","title":"Proof Verification Method"},{"location":"Specs/Ethereum-Attestation-Registry-Proof-Type/#performance-considerations","text":"With this proof type, an Ethereum transaction must be executed for each new attestation. This specification should be improved in the future to allow more scalable approaches.","title":"Performance Considerations"},{"location":"Specs/GID-DID-Method/","text":"GlobalID DID Method Abstract This document describes the GlobalID DID method. It conforms to the requirements specified in the DID draft specification currently published by the W3C Credentials Community Group. Status of this Document This specification is an unofficial draft. It is provided as a reference for people and organisations who wish to implement software meant to interact with GlobalID DID method. Introduction The DID specification seeks to facilitate internet-wide, self-sovereign identity. On that basis, identifiers must be both assigned, resolved and used in a decentralised way. Every GlobalID DID lives on a specific Ethereum blockchain and translates naturally to and from an Ethereum address on that blockchain, representing the entity in front of DApps. Additionally, any system that has access to a node in the same blockchain as a DID may perform (read, write, auth...) operations on that DID and use it off-chain if needed. The purpose of DIDs, and URIs in general, is interoperability. For that reason, GlobalID DIDs are as compatible as possible with existing standards such as Verifiable Credentials, and try to not impose that other actors in a given interaction use the same blockchain, the same DID method, or even a DID as their identifier. Terminology DID: A distributed identifier Entity: Any person, organization, thing, vehicle, house, etc. that may be uniquely identified. DIDs DID format The DID specification defines the following format for DIDs: did:<scheme>:<scheme-specific-identifier> DID Method Name The scheme that shall identify this DID method is: gid . Method-Specific Identifier The method-specific identifier is composed of an optional Ethereum network identifier with a : separator, followed by an MNID. gid-did = \"did:gid:\" mnid mnid = 40*HEXDIG The mnid is a string that is compliant with the Multi-Network ID format . It refers to the Multi-Network identifier of the identity's Proxy contract. An MNID is an encoding of an (address, networkID) pair, so it's possible to compute a DID from an address and networkID pair, and vice versa. Assuming networkIDs are unique and well known, a DID thus allows to discover the specific Proxy contract behind a given DID, and reciprocally. Example Example gid DID: did:gid:2uzPtwJmXbBqMmP9DkR7dE3FcLmgYejdJ42 DID Document Example { \"@context\": \"https://w3id.org/did/v1\", \"id\": \"did:gid:2uzPtwJmXbBqMmP9DkR7dE3FcLmgYejdJ42\", \"authentication\": [{ \"id\": \"did:gid:2uzPtwJmXbBqMmP9DkR7dE3FcLmgYejdJ42#keys-1\", \"type\": \"EthereumAddress\", \"controller\": \"did:gid:2uzPtwJmXbBqMmP9DkR7dE3FcLmgYejdJ42\", \"publicKeyAddress\": \"0xaeaefd50a2c5cda393e9a1eef2d6ba23f2c4fd6d\" }] } CRUD Operation Definitions Each identity is represented by the address of a smart contract called \"Proxy contract\", available on an Ethereum network. Create (Register) In order to create an gid DID, a Proxy contract must be deployed on Ethereum. The address of the deployed contract is used to compute the DID using the following algorithm: 1. The contract's address and the Ethereum network ID are put together and converted into an MNID. 2. The string \"did:gid:\" is prepended to the MNID. Read (Resolve) To construct a valid DID document from an gid DID, the following steps are performed: Extract the MNID as the method-specific part of the DID Determine the Ethereum network identifier and address from the MNID. Access relevant information about that DID: public profile, public keys authorized for authentication, etc. Update Only an authorized device for a given DID may update information about that DID. Delete (Revoke) The delete operation is not currently supported. However, for must use cases it is sufficient to stop using a given DID, authenticating as that DID, or providing private or public information about it. Performance Considerations In Ethereum, looking up a raw public key from a native 20-byte address is a complex and resource-intensive process, which is why this specification refers to public keys in their \"address\" hash form. This makes the DID method much simpler to implement, while at the same time not really limiting the spirit of the DID specification.","title":"GlobalID DID Method"},{"location":"Specs/GID-DID-Method/#globalid-did-method","text":"","title":"GlobalID DID Method"},{"location":"Specs/GID-DID-Method/#abstract","text":"This document describes the GlobalID DID method. It conforms to the requirements specified in the DID draft specification currently published by the W3C Credentials Community Group.","title":"Abstract"},{"location":"Specs/GID-DID-Method/#status-of-this-document","text":"This specification is an unofficial draft. It is provided as a reference for people and organisations who wish to implement software meant to interact with GlobalID DID method.","title":"Status of this Document"},{"location":"Specs/GID-DID-Method/#introduction","text":"The DID specification seeks to facilitate internet-wide, self-sovereign identity. On that basis, identifiers must be both assigned, resolved and used in a decentralised way. Every GlobalID DID lives on a specific Ethereum blockchain and translates naturally to and from an Ethereum address on that blockchain, representing the entity in front of DApps. Additionally, any system that has access to a node in the same blockchain as a DID may perform (read, write, auth...) operations on that DID and use it off-chain if needed. The purpose of DIDs, and URIs in general, is interoperability. For that reason, GlobalID DIDs are as compatible as possible with existing standards such as Verifiable Credentials, and try to not impose that other actors in a given interaction use the same blockchain, the same DID method, or even a DID as their identifier.","title":"Introduction"},{"location":"Specs/GID-DID-Method/#terminology","text":"DID: A distributed identifier Entity: Any person, organization, thing, vehicle, house, etc. that may be uniquely identified.","title":"Terminology"},{"location":"Specs/GID-DID-Method/#dids","text":"","title":"DIDs"},{"location":"Specs/GID-DID-Method/#did-format","text":"The DID specification defines the following format for DIDs: did:<scheme>:<scheme-specific-identifier>","title":"DID format"},{"location":"Specs/GID-DID-Method/#did-method-name","text":"The scheme that shall identify this DID method is: gid .","title":"DID Method Name"},{"location":"Specs/GID-DID-Method/#method-specific-identifier","text":"The method-specific identifier is composed of an optional Ethereum network identifier with a : separator, followed by an MNID. gid-did = \"did:gid:\" mnid mnid = 40*HEXDIG The mnid is a string that is compliant with the Multi-Network ID format . It refers to the Multi-Network identifier of the identity's Proxy contract. An MNID is an encoding of an (address, networkID) pair, so it's possible to compute a DID from an address and networkID pair, and vice versa. Assuming networkIDs are unique and well known, a DID thus allows to discover the specific Proxy contract behind a given DID, and reciprocally.","title":"Method-Specific Identifier"},{"location":"Specs/GID-DID-Method/#example","text":"Example gid DID: did:gid:2uzPtwJmXbBqMmP9DkR7dE3FcLmgYejdJ42","title":"Example"},{"location":"Specs/GID-DID-Method/#did-document","text":"","title":"DID Document"},{"location":"Specs/GID-DID-Method/#example_1","text":"{ \"@context\": \"https://w3id.org/did/v1\", \"id\": \"did:gid:2uzPtwJmXbBqMmP9DkR7dE3FcLmgYejdJ42\", \"authentication\": [{ \"id\": \"did:gid:2uzPtwJmXbBqMmP9DkR7dE3FcLmgYejdJ42#keys-1\", \"type\": \"EthereumAddress\", \"controller\": \"did:gid:2uzPtwJmXbBqMmP9DkR7dE3FcLmgYejdJ42\", \"publicKeyAddress\": \"0xaeaefd50a2c5cda393e9a1eef2d6ba23f2c4fd6d\" }] }","title":"Example"},{"location":"Specs/GID-DID-Method/#crud-operation-definitions","text":"Each identity is represented by the address of a smart contract called \"Proxy contract\", available on an Ethereum network.","title":"CRUD Operation Definitions"},{"location":"Specs/GID-DID-Method/#create-register","text":"In order to create an gid DID, a Proxy contract must be deployed on Ethereum. The address of the deployed contract is used to compute the DID using the following algorithm: 1. The contract's address and the Ethereum network ID are put together and converted into an MNID. 2. The string \"did:gid:\" is prepended to the MNID.","title":"Create (Register)"},{"location":"Specs/GID-DID-Method/#read-resolve","text":"To construct a valid DID document from an gid DID, the following steps are performed: Extract the MNID as the method-specific part of the DID Determine the Ethereum network identifier and address from the MNID. Access relevant information about that DID: public profile, public keys authorized for authentication, etc.","title":"Read (Resolve)"},{"location":"Specs/GID-DID-Method/#update","text":"Only an authorized device for a given DID may update information about that DID.","title":"Update"},{"location":"Specs/GID-DID-Method/#delete-revoke","text":"The delete operation is not currently supported. However, for must use cases it is sufficient to stop using a given DID, authenticating as that DID, or providing private or public information about it.","title":"Delete (Revoke)"},{"location":"Specs/GID-DID-Method/#performance-considerations","text":"In Ethereum, looking up a raw public key from a native 20-byte address is a complex and resource-intensive process, which is why this specification refers to public keys in their \"address\" hash form. This makes the DID method much simpler to implement, while at the same time not really limiting the spirit of the DID specification.","title":"Performance Considerations"},{"location":"Specs/Proxy-Contract-ERC/","text":"eip: <to be assigned> title: ERC: Identity Proxy Contract author: David Ammouial (@davux) <dammouia@everis.com> status: Draft type: Standards Track category: ERC created: 2019-06-04 Simple Summary Identity contract Abstract This ERC describes the interface used for identity management: creation of an identity, update of information related to an identity, and action on behalf of an identity. Motivation There is a need to standardize the interface for contract-based digital identities to be used, so as to allow for interoperability between implementations. Definitions Owner The owner of an identity (i.e. Proxy contract) is an Ethereum address recognized by the Proxy contract to originate transactions that the Proxy contract will forward. While the address of a Proxy contract is permanent, owners may be added and removed as needed. Specification This EIP defines an interface called Proxy , which provides the following functions: constructor The constructor is used to instantiate a new identity (i.e. Proxy contract). It takes a firstOwner address of that proxy. constructor(firstOwner) public forward Used to instruct the smart contract to execute a given function (in the form of its bytecode data ) and/or transfer a certain value of ethers to a given destination smart contract. function forward(address destination, uint value, bytes data) public; isOwner Returns whether a given address is allowed to execute forward on the smart contract. function isOwner(address) public returns (bool); addOwner function addOwner(address newOwner) public; Used to add a newOwner address as an owner of the smart contract. renounce Used to give up ownership of the smart contract. function renounce() public; In addition, this EIP defines the following events: OwnerAdded This event is emitted everytime a newOwner address is added to the contract. OwnerAdded(address indexed newOwner) OwnerRemoved This event is emitted everytime a formerOwner address is removed from the contract. OwnerRemoved(address indexed formerOwner) Rationale For digital identity to be self-sovereign, it needs to be able to rely on a trusted, decentralized backbone. Ethereum blockchain is a satisfying component for that requisite. Backwards Compatibility This EIP doesn't introduce any known backwards compatibility issues. However, it does a similar job as other ERCs such as ERC-725 and others, and there are plans to integrate the most recent developments into this EIP. Implementation KayTrust Provider web application and KayTrust Wallet mobile application provide an implementation of the Proxy contract. Copyright Copyright and related rights waived via CC0 .","title":"Proxy Contract ERC"},{"location":"Specs/Proxy-Contract-ERC/#simple-summary","text":"Identity contract","title":"Simple Summary"},{"location":"Specs/Proxy-Contract-ERC/#abstract","text":"This ERC describes the interface used for identity management: creation of an identity, update of information related to an identity, and action on behalf of an identity.","title":"Abstract"},{"location":"Specs/Proxy-Contract-ERC/#motivation","text":"There is a need to standardize the interface for contract-based digital identities to be used, so as to allow for interoperability between implementations.","title":"Motivation"},{"location":"Specs/Proxy-Contract-ERC/#definitions","text":"Owner The owner of an identity (i.e. Proxy contract) is an Ethereum address recognized by the Proxy contract to originate transactions that the Proxy contract will forward. While the address of a Proxy contract is permanent, owners may be added and removed as needed.","title":"Definitions"},{"location":"Specs/Proxy-Contract-ERC/#specification","text":"This EIP defines an interface called Proxy , which provides the following functions: constructor The constructor is used to instantiate a new identity (i.e. Proxy contract). It takes a firstOwner address of that proxy. constructor(firstOwner) public forward Used to instruct the smart contract to execute a given function (in the form of its bytecode data ) and/or transfer a certain value of ethers to a given destination smart contract. function forward(address destination, uint value, bytes data) public; isOwner Returns whether a given address is allowed to execute forward on the smart contract. function isOwner(address) public returns (bool); addOwner function addOwner(address newOwner) public; Used to add a newOwner address as an owner of the smart contract. renounce Used to give up ownership of the smart contract. function renounce() public; In addition, this EIP defines the following events: OwnerAdded This event is emitted everytime a newOwner address is added to the contract. OwnerAdded(address indexed newOwner) OwnerRemoved This event is emitted everytime a formerOwner address is removed from the contract. OwnerRemoved(address indexed formerOwner)","title":"Specification"},{"location":"Specs/Proxy-Contract-ERC/#rationale","text":"For digital identity to be self-sovereign, it needs to be able to rely on a trusted, decentralized backbone. Ethereum blockchain is a satisfying component for that requisite.","title":"Rationale"},{"location":"Specs/Proxy-Contract-ERC/#backwards-compatibility","text":"This EIP doesn't introduce any known backwards compatibility issues. However, it does a similar job as other ERCs such as ERC-725 and others, and there are plans to integrate the most recent developments into this EIP.","title":"Backwards Compatibility"},{"location":"Specs/Proxy-Contract-ERC/#implementation","text":"KayTrust Provider web application and KayTrust Wallet mobile application provide an implementation of the Proxy contract.","title":"Implementation"},{"location":"Specs/Proxy-Contract-ERC/#copyright","text":"Copyright and related rights waived via CC0 .","title":"Copyright"},{"location":"Specs/Trusted-Credentials/","text":"Trusted Credentials Motivation Verifiable credentials make claims about a subject. While it is possible for a verifier to deterministically check that a credential actually came from its listed issuer without modifications, the decision of whether that issuer is relevant for the claims is subjective. For example, a police officer in Germany might verify that a driving license from Canada is genuine, but that doesn't mean they will accept the Canadian government as a relevant authority and let you drive. That decision is up to the police and based e.g. on international agreements between countries. In some cases, verifiers' criteria are as simple as recognizing a set of authorities for certain types of claims or credentials. In other cases, the decision involves delegation and roots of authority. Such a setup is similar to the Public Key Infrastructure (PKI) for X.509 certificates, but with different chains of trust depending on the type of information \u2013 the authorities for academic credentials are not the same as for citizenship or banking information. Definitions and concepts Authority An authority for a type of claim (e.g. identity document number, phone number, email address) is an entity that is trusted by a verifier to issue reliable claims of that type. Being or not an authority for a given type of claim depends on each verifier: a same entity is an authority to some verifiers but not to others. Trusted claim A claim is trusted by a verifier if either: The verifier considers the issuer of the containing credential to be an authority for that claim ( implicit trust ). Or the verifier decides to trust the claim directly, based on the verifier's own rules ( explicit trust ). Delegation: depths of authority Some entities, such as governments, have the authority to issue claims themselves but choose to delegate that authority to other entities. Examples: A car reseller may attest to a car's functioning state but may not delegate that authority to another entity (authority with depth 0). A car brand may give authority to car resellers to attest to a car's functioning state (depth 1). A university may issue diplomas but may not delegate that authority (depth 0). The Ministry of Education of a country may give authority to universities to issue diplomas (depth 1). The government of a country may give authority to the Ministry of Education to give that authority to universities (depth 2). Big picture Technical specification Schema The following schema is used in a Verifiable Credential issued by \"entity A\" to say that \"entity B\" is authoritative for a given claim type. \"issuer\": \"did:xxx:entityA\", \"credentialSubject\": { \"id\": \"did:xxx:entityB\" \"credentialAuthority\": { \"authoritativeFor\": \"http://schema.org/driverLicense\", # The type of claim the entity is authoritative for \"depth\": 2 # Number of delegation hops, defaults to 0 } } Trusting claims A claim can be either implicitly or explicitly trusted. The sections below detail how trust is determined in either case. Implicit trust is defined recursively, with explicit trust being the exit case of the recursivity. Implicit trust A claim is implicitly trusted when the issuer of the credential is considered an authority for that claim. As an example, let's say the verifier has access to a credential such as the one in the example from the \"Schema\" section above. If the verifier trusts (implicitly or explicitly) that credentialAuthority claim, then they will implicitly trust the following types of claims contained by any credential issued by \"entity B\": Any driverLicense claim. Any credentialAuthority claim with depth strictly lower than 2, and about driverLicense claims. Example credentials for either case: \"issuer\": \"did:xxx:entityB\", \"credentialSubject\": { \"id\": \"did:xxx:entityC\", \"driverLicense\": { ... } } \"issuer\": \"did:xxx:entityB\", \"credentialSubject\": { \"id\": \"did:xxx:entityC\", \"credentialAuthority\": { \"authoritativeFor\": \"http://schema.org/driverLicense\", \"depth\": 1 } } Example scenario: Recruiter X receives a credential claiming that John Doe has a Doctorate in Rocket Science (modelled as \"diploma\"). That credential is issued by University of the North. University of the North, in a separate credential, claims to be an authority for claims of type \"diploma\" with default depth 0. That second credential was issued by Ministry of Education. Ministry of Education, in a separate credential, claims to be an authority for \"diploma\" claims, with depth 1. That third credential is signed by Government of Country X. Government of Country X, in a separate credential, claims to be authoritative for claim \"diploma\" with depth 3. That third credential is explicitly trusted by the verifier (see below). As a result, Recruiter X implicitly trusts John Doe's diploma. Explicit trust A claim is explicitly trusted when the verifier makes the decision based on its own (business, regulatory, etc.) rules. This is the simplest case. Example scenarios: An identity wallet may allow the user to manually trust a specific credential. A verifier may choose to accept self-issued credentials (i.e. the subject is the issuer) for some claims. Big Buck Bank chooses to explicitly trust a specific financial institution as an authority for credit score claims. Recruiter X knows the DIDs of recognized universities and decides to trust any diplomas issued by those DIDs, for a specific range of issuance date. Ask Y chooses to trust a specific public institution for credentialAuthority claims and a given depth, making that issuer a \"Root authority\" in a chain of trust. Notes Transitivity of trust delegation: friend of a friend of a friend of... This specification defines implicit trust in a recursive way, with explicit trust being the exit condition. However, to prevent infinite loops and to avoid ridiculously long trust chains, verifiers may decide to put a practical limit to how many hops they support. Distribution of authority credentials This data model relies on the verifier's access to \"trust credentials\" in addition to the credential of first interest. This is similar to SSL's requirement for the server to distribute the complete chain of trust during handshake. Although this data model doesn't define a way for the holder to distribute the relevant trust credentials, a good practice might be to include all relevant credentials in a Verifiable Presentation. That being said, depending on the context the holder can assume that the verifier already trusts some of the involved authorities and thus avoid \"stating the obvious\". Value constraints This model doesn't place any constraints on the value of the claims. For example, University of the North may not be an authority for Doctorates in Rocket Science but only for Masters in Literature. However, that limitation shouldn't be a problem thanks to the trust model. If an entity abuses their authority and starts signing certificates that they shouldn't, or otherwise fails to demonstrate that they're following a rigorous issuance process, they will take the risk of losing their status as an authority. Note the similarity with the inclusion of Root CAs by browsers in traditional PKI. Relation with eIDAS Verifiable Credentials may contain a levelOfAssurance attribute as part of their metadata (i.e. at the same level as credentialSubject ). The value of that property indicates how reliable the claims contained in the credential are. The credentialAuthority claims discussed in this specification play nicely with a credential's level of assurance, because the level of assurance of such credentials indicates the level of assurance given to that issuer by a higher-level authority. Example 1: level of assurance for a normal credential The credential below claims the name of subject did:xxx:abc to be John Doe, with a level of assurance \"High\" set by issuer did:xxx:def . { \"@type\": \"VerifiableCredential\", \"credentialSubject\": { \"@context\": \"http://schema.org/\", \"@id\": \"did:xxx:abc\", \"name\": \"John Doe\" }, \"levelOfAssurance\": \"High\", \"issuer\": \"did:xxx:def\" } Example 2: level of assurance for an authority The credential below claims that subject did:xxx:def (issuer of the credential above) is an authority for claims of type name , with a level of assurance \"High\" set by higher-level authority did:xxx:ghi . { \"@type\": \"VerifiableCredential\", \"credentialSubject\": { \"@context\": \"http://schema.kaytrust.id/\", \"@id\": \"did:xxx:def\", \"credentialAuthority\": { \"authoritativeFor\": \"http://schema.org/name\" } }, \"levelOfAssurance\": \"High\", \"issuer\": \"did:xxx:ghi\" } If the verifier trusts did:xxx:ghi with that level of assurance, then they will also trust John Doe's credential with the same level of assurance, per eiDAS rules.","title":"Trusted Credentials"},{"location":"Specs/Trusted-Credentials/#trusted-credentials","text":"","title":"Trusted Credentials"},{"location":"Specs/Trusted-Credentials/#motivation","text":"Verifiable credentials make claims about a subject. While it is possible for a verifier to deterministically check that a credential actually came from its listed issuer without modifications, the decision of whether that issuer is relevant for the claims is subjective. For example, a police officer in Germany might verify that a driving license from Canada is genuine, but that doesn't mean they will accept the Canadian government as a relevant authority and let you drive. That decision is up to the police and based e.g. on international agreements between countries. In some cases, verifiers' criteria are as simple as recognizing a set of authorities for certain types of claims or credentials. In other cases, the decision involves delegation and roots of authority. Such a setup is similar to the Public Key Infrastructure (PKI) for X.509 certificates, but with different chains of trust depending on the type of information \u2013 the authorities for academic credentials are not the same as for citizenship or banking information.","title":"Motivation"},{"location":"Specs/Trusted-Credentials/#definitions-and-concepts","text":"","title":"Definitions and concepts"},{"location":"Specs/Trusted-Credentials/#authority","text":"An authority for a type of claim (e.g. identity document number, phone number, email address) is an entity that is trusted by a verifier to issue reliable claims of that type. Being or not an authority for a given type of claim depends on each verifier: a same entity is an authority to some verifiers but not to others.","title":"Authority"},{"location":"Specs/Trusted-Credentials/#trusted-claim","text":"A claim is trusted by a verifier if either: The verifier considers the issuer of the containing credential to be an authority for that claim ( implicit trust ). Or the verifier decides to trust the claim directly, based on the verifier's own rules ( explicit trust ).","title":"Trusted claim"},{"location":"Specs/Trusted-Credentials/#delegation-depths-of-authority","text":"Some entities, such as governments, have the authority to issue claims themselves but choose to delegate that authority to other entities. Examples: A car reseller may attest to a car's functioning state but may not delegate that authority to another entity (authority with depth 0). A car brand may give authority to car resellers to attest to a car's functioning state (depth 1). A university may issue diplomas but may not delegate that authority (depth 0). The Ministry of Education of a country may give authority to universities to issue diplomas (depth 1). The government of a country may give authority to the Ministry of Education to give that authority to universities (depth 2).","title":"Delegation: depths of authority"},{"location":"Specs/Trusted-Credentials/#big-picture","text":"","title":"Big picture"},{"location":"Specs/Trusted-Credentials/#technical-specification","text":"","title":"Technical specification"},{"location":"Specs/Trusted-Credentials/#schema","text":"The following schema is used in a Verifiable Credential issued by \"entity A\" to say that \"entity B\" is authoritative for a given claim type. \"issuer\": \"did:xxx:entityA\", \"credentialSubject\": { \"id\": \"did:xxx:entityB\" \"credentialAuthority\": { \"authoritativeFor\": \"http://schema.org/driverLicense\", # The type of claim the entity is authoritative for \"depth\": 2 # Number of delegation hops, defaults to 0 } }","title":"Schema"},{"location":"Specs/Trusted-Credentials/#trusting-claims","text":"A claim can be either implicitly or explicitly trusted. The sections below detail how trust is determined in either case. Implicit trust is defined recursively, with explicit trust being the exit case of the recursivity.","title":"Trusting claims"},{"location":"Specs/Trusted-Credentials/#implicit-trust","text":"A claim is implicitly trusted when the issuer of the credential is considered an authority for that claim. As an example, let's say the verifier has access to a credential such as the one in the example from the \"Schema\" section above. If the verifier trusts (implicitly or explicitly) that credentialAuthority claim, then they will implicitly trust the following types of claims contained by any credential issued by \"entity B\": Any driverLicense claim. Any credentialAuthority claim with depth strictly lower than 2, and about driverLicense claims. Example credentials for either case: \"issuer\": \"did:xxx:entityB\", \"credentialSubject\": { \"id\": \"did:xxx:entityC\", \"driverLicense\": { ... } } \"issuer\": \"did:xxx:entityB\", \"credentialSubject\": { \"id\": \"did:xxx:entityC\", \"credentialAuthority\": { \"authoritativeFor\": \"http://schema.org/driverLicense\", \"depth\": 1 } } Example scenario: Recruiter X receives a credential claiming that John Doe has a Doctorate in Rocket Science (modelled as \"diploma\"). That credential is issued by University of the North. University of the North, in a separate credential, claims to be an authority for claims of type \"diploma\" with default depth 0. That second credential was issued by Ministry of Education. Ministry of Education, in a separate credential, claims to be an authority for \"diploma\" claims, with depth 1. That third credential is signed by Government of Country X. Government of Country X, in a separate credential, claims to be authoritative for claim \"diploma\" with depth 3. That third credential is explicitly trusted by the verifier (see below). As a result, Recruiter X implicitly trusts John Doe's diploma.","title":"Implicit trust"},{"location":"Specs/Trusted-Credentials/#explicit-trust","text":"A claim is explicitly trusted when the verifier makes the decision based on its own (business, regulatory, etc.) rules. This is the simplest case. Example scenarios: An identity wallet may allow the user to manually trust a specific credential. A verifier may choose to accept self-issued credentials (i.e. the subject is the issuer) for some claims. Big Buck Bank chooses to explicitly trust a specific financial institution as an authority for credit score claims. Recruiter X knows the DIDs of recognized universities and decides to trust any diplomas issued by those DIDs, for a specific range of issuance date. Ask Y chooses to trust a specific public institution for credentialAuthority claims and a given depth, making that issuer a \"Root authority\" in a chain of trust.","title":"Explicit trust"},{"location":"Specs/Trusted-Credentials/#notes","text":"","title":"Notes"},{"location":"Specs/Trusted-Credentials/#transitivity-of-trust-delegation-friend-of-a-friend-of-a-friend-of","text":"This specification defines implicit trust in a recursive way, with explicit trust being the exit condition. However, to prevent infinite loops and to avoid ridiculously long trust chains, verifiers may decide to put a practical limit to how many hops they support.","title":"Transitivity of trust delegation: friend of a friend of a friend of..."},{"location":"Specs/Trusted-Credentials/#distribution-of-authority-credentials","text":"This data model relies on the verifier's access to \"trust credentials\" in addition to the credential of first interest. This is similar to SSL's requirement for the server to distribute the complete chain of trust during handshake. Although this data model doesn't define a way for the holder to distribute the relevant trust credentials, a good practice might be to include all relevant credentials in a Verifiable Presentation. That being said, depending on the context the holder can assume that the verifier already trusts some of the involved authorities and thus avoid \"stating the obvious\".","title":"Distribution of authority credentials"},{"location":"Specs/Trusted-Credentials/#value-constraints","text":"This model doesn't place any constraints on the value of the claims. For example, University of the North may not be an authority for Doctorates in Rocket Science but only for Masters in Literature. However, that limitation shouldn't be a problem thanks to the trust model. If an entity abuses their authority and starts signing certificates that they shouldn't, or otherwise fails to demonstrate that they're following a rigorous issuance process, they will take the risk of losing their status as an authority. Note the similarity with the inclusion of Root CAs by browsers in traditional PKI.","title":"Value constraints"},{"location":"Specs/Trusted-Credentials/#relation-with-eidas","text":"Verifiable Credentials may contain a levelOfAssurance attribute as part of their metadata (i.e. at the same level as credentialSubject ). The value of that property indicates how reliable the claims contained in the credential are. The credentialAuthority claims discussed in this specification play nicely with a credential's level of assurance, because the level of assurance of such credentials indicates the level of assurance given to that issuer by a higher-level authority.","title":"Relation with eIDAS"},{"location":"Specs/Trusted-Credentials/#example-1-level-of-assurance-for-a-normal-credential","text":"The credential below claims the name of subject did:xxx:abc to be John Doe, with a level of assurance \"High\" set by issuer did:xxx:def . { \"@type\": \"VerifiableCredential\", \"credentialSubject\": { \"@context\": \"http://schema.org/\", \"@id\": \"did:xxx:abc\", \"name\": \"John Doe\" }, \"levelOfAssurance\": \"High\", \"issuer\": \"did:xxx:def\" }","title":"Example 1: level of assurance for a normal credential"},{"location":"Specs/Trusted-Credentials/#example-2-level-of-assurance-for-an-authority","text":"The credential below claims that subject did:xxx:def (issuer of the credential above) is an authority for claims of type name , with a level of assurance \"High\" set by higher-level authority did:xxx:ghi . { \"@type\": \"VerifiableCredential\", \"credentialSubject\": { \"@context\": \"http://schema.kaytrust.id/\", \"@id\": \"did:xxx:def\", \"credentialAuthority\": { \"authoritativeFor\": \"http://schema.org/name\" } }, \"levelOfAssurance\": \"High\", \"issuer\": \"did:xxx:ghi\" } If the verifier trusts did:xxx:ghi with that level of assurance, then they will also trust John Doe's credential with the same level of assurance, per eiDAS rules.","title":"Example 2: level of assurance for an authority"},{"location":"Tutorials/java-sdk/","text":"Kaytrust Core SDK Introduction Kaytrust Core SDK is a library built on java, it allows developers to interact with the Lacchain Ethereum Network in order to perform actions related to the creation and validation of Identities and verifiable credentials. Key concepts and considerations public/private keys used here are based on elliptic curve cryptography. did: Decentralized Identifier. A a new type of identifier for verifiable, decentralized digital identity. Find the W3C definition here Verifiable credential: a tamper-evident credential that has authorship that can be cryptographically verified. Verifiable credentials can be used to build verifiable presentations, which can also be cryptographically verified. The claims in a credential can be about different subjects. Reference: https://www.w3.org/TR/vc-imp-guide/ Examples: https://www.w3.org/TR/vc-imp-guide/#example-1-a-subject-disputes-a-credential Address: Is the short descriptor, composed with 40 hexadecimal characters, which is derived from the ECC public key. Capability: This an authorization capability which is set in the identity Manager smart contract. Capabilities associate granted permissions over a proxy address for a certain or indefinitely time. There are four defined capalibities (forward, devicemanager, admin and auth) Device authorization validation: Means verifying that a certain device(identified by a public key) has a capability to perform some action related to the Proxy contract. Identity Provider: This is the entity that helps users create their identities and more importantly helps to recover the user identity in case a user is not able to access its identity. Issue a credential: The process by which an issuer emits a verifiable credential on behalf of a user, the proof of validity is a signed range of time in which a hash (that represents a verifiable credential) is made available on a smart contract (Verification Registry). Requisites Java 8 Repository URL link here What can I do with this SDK? Identity creation for a user: This functionality can be in two steps: An Identity Provider creates an identity, the SDK goes to the blockchain and creates a new identity for you. As a result a decentralized identity is returned. Lets see it in a diagram: The provider associates the user's device address with the did obtained in the previous step. Note : Adding another device follows the exact process, but the did (that contains the smart contract proxy address) must be specified. In a later example this will be explained with an example. Device Autorization Validation: Check what a device can do (these are known as capabilities given to different devices). Issue a Verifiable Credential: Lets see what is the flow when this sdk generates a verifiable credential Check for a verifiable credential validity Examples You can also find all examples in src/test into the packages: id.kaytrust.core.identity.ethereum id.kaytrust.core.verifiableCredential.ethereum Assumptions: A new user wants to deploy a new contract (Proxy contract) that represents its identity, the user will do this through the existing Identity Manager contract, it will create the Proxy and make the association between the user'\u015b device and the Proxy Contract. Previous setting Setting an Identity Manager instance EthereumIdentityManager identityManager; String rpcConnection = \"http://eth-lacchain.kaytrust.id\"; //The ethereum node to access the Lacchain Network String IdentityManagerContractAddress = \"0xa6b4540a2bfbe8663caa78027c83d0dcb1b7c837\"; //This is the existing IdentityManager contract address String providerPrivateKey = \"0x9eb5a43839e8ff36fcdaed658136c51623be3af7de304d1c9181a6be9fac0863\"; //Provider private key { identityManager = new EthereumIdentityManagerImpl(); //Sets a new instance of IdentityManager to interact with. try { identityManager.instance(rpcConnection, providerPrivateKey, IdentityManagerContractAddress); } catch (Exception e) { e.printStackTrace(); } } Creating a new Identity with the provider key try{ System.out.println(\"*****************************************************************************\"); System.out.println(\"************************* Create Identity ********************************\"); String did = identityManager.createIdentity(); //Deploys a new Proxy Contract and sets Identity Provider private key // with all capabilities (it allows recovery functionalities) // Now verifying the did is not null boolean isTrue = !did.isEmpty(); System.out.println(\"Created DID: \" + did);//At this point only the identity provider has authorization over the proxy if (isTrue){ System.out.println(\"SUCCESS\"); } assertNotNull(did); }catch(Exception e){ e.printStackTrace(); fail(); } By creating an Identity a new did (decentralized identifier) is returned, this did has been associated with a provider address. At this point only the provider can add devices on behalf of a user. Associating a user's device address to the new proxy contract identity. try { System.out.println(\"*****************************************************************************\"); System.out.println(\"************************* Authorize Device *******************************\"); String devicePublicKey = \"fadb30ab306603e1806e1fbd324cf21aaefb32c8a1f3f4cf701f3eafd17df68e97ec33dd77d7d6e7dc436905dc47f2f3da907e3a3be05cce348d10d51323dd5e\"; identityManager.authorizeDevice(did, devicePublicKey, CapabilityEnum.FORWARD.description()); //Setting forward // capability, between the Proxy and the device, in the IdentityManager contract. System.out.println(\"SUCCESS\"); assertNotNull(did); } catch (Exception e) { System.out.println(\"FAILED\"); e.printStackTrace(); fail(); } Notes: Note that the identity Manager instance has been initialized with a private key that has all permissions over the deployed proxy, that is why it is possible to associate a new device with the Proxy contract. The association process can be repeated \"n\" times to add as many devices as requrired. Identity Validation Now that a new did has been created lets verify if the \"deviceA\" has the \"forward\" capability. Note the some variables which has been previously defined are been reused. try { EthereumIdentityConsumer identityConsumer=new EthereumIdentityConsumerImpl(); identityConsumer.instance(rpcConnection, null, identityManagerContractAddress); boolean isTrue = identityConsumer.isDeviceAuthorized(did, devicePublicKey,CapabilityEnum.FORWARD.description());//you can check other capabilities like FORWARD, AUTH or DEVICE_MANAGER if (isTrue){ System.out.println(\"SUCCESS\"); } assertTrue(isTrue); } catch (Exception e) { e.printStackTrace(); fail(); } Issuing a credential Setting a Subject example class definition: //Setting a Subject example class definition: class CredentialSubject { @SerializedName(\"@id\") String id; String name; String birthDate; } //Defining general variables before executing examples related to credential issuance String issuerPrivateKey; EthereumCredentialIssuer credentialIssuer; { String verificationRegistryContractAddress = \"0x9f8c1e196F5696e014F4d1E4961B92db866BE271\"; credentialIssuer = new EthereumCredentialIssuerImpl(); try { issuerPrivateKey = \"0x9eb5a43839e8ff36fcdaed658136c51623be3af7de304d1c9181a6be9fac0863\"; credentialIssuer.instance(rpcConnection, issuerPrivateKey, verificationRegistryContractAddress); } catch (Exception e) { e.printStackTrace(); } } Issuance process: public void issueCredential() { System.out.println(\"*****************************************************************************\"); System.out.println(\"************************* Credential Issuance *******************************\"); try { String subject = \"{\" + \"\\\"@id\\\":\" + \"\\\"did:ev:cwMLLiMQGm9EaTqzY2k58refSoXdTsYvJ9Znp\\\",\" + \"\\\"name\\\":\\\"John Doe\\\",\" + \"\\\"birthDate\\\":\\\"2018-01-01\\\"}\"; CredentialSubject sc = new Gson().fromJson(subject, CredentialSubject.class); String[] credentialType = { \"VerifiableCredential\", \"MyCustomType\" }; String vc = credentialIssuer.issueCredential(sc, credentialType, null, null, new EthereumAttestation2019Builder(), null); log.info(\"verificationCredential :\\n {} \",vc); if (!vc.isEmpty()){ log.info(\"SUCCESS\"); } assertNotNull(vc); } catch (Exception e) { e.printStackTrace(); fail(); } } Checking for a Verifiable credential validity Previous setting EthereumCredentialValidation credentialValidation; { System.out.println(\"********************** Credential ValidationTest - Previous Setting ****************************\"); credentialValidation = new EthereumCredentialValidationImpl(); try { credentialValidation.instance(rpcConnection, issuerPrivateKey, verificationRegistryContractAddress, new EthereumAttestation2019Builder()); System.out.println(\"Verifiable credential is: \" + vc + \"\\nIssued by \" + (EthereumKeyUtils.getAddressFromPrivateKey(issuerPrivateKey))); } catch (Exception e) { e.printStackTrace(); } } It is time to check if a verifiable credential is valid or not, by checking if an issuer has registered a credential hash on the Verification Registry contract public void credentialCheckingTest() { System.out.println(\"*****************************************************************************\"); System.out.println(\"********************** Credential ValidationTest ****************************\"); try { System.out.println(\"Verifying \" + (EthereumKeyUtils.getAddressFromPrivateKey(issuerPrivateKey)) +\" has emitted the verifiable credential and also the verifiable credential is not expired...\"); //Note that it is not necessary to have the private key but only the issuer address. boolean isValidCredential = credentialValidation.verifyCredential(vc);//returns \"true\" if the verifiable credential is valid; otherwise \"false\"; //in this case we are simply using the verifiable credential that was returned in the previous step. if (isValidCredential){ log.info(\"SUCCESS\"); } assertTrue(isValidCredential); } catch (Exception e) { e.printStackTrace(); fail(); } }","title":"Kaytrust Core SDK"},{"location":"Tutorials/java-sdk/#kaytrust-core-sdk","text":"","title":"Kaytrust Core SDK"},{"location":"Tutorials/java-sdk/#introduction","text":"Kaytrust Core SDK is a library built on java, it allows developers to interact with the Lacchain Ethereum Network in order to perform actions related to the creation and validation of Identities and verifiable credentials.","title":"Introduction"},{"location":"Tutorials/java-sdk/#key-concepts-and-considerations","text":"public/private keys used here are based on elliptic curve cryptography. did: Decentralized Identifier. A a new type of identifier for verifiable, decentralized digital identity. Find the W3C definition here Verifiable credential: a tamper-evident credential that has authorship that can be cryptographically verified. Verifiable credentials can be used to build verifiable presentations, which can also be cryptographically verified. The claims in a credential can be about different subjects. Reference: https://www.w3.org/TR/vc-imp-guide/ Examples: https://www.w3.org/TR/vc-imp-guide/#example-1-a-subject-disputes-a-credential Address: Is the short descriptor, composed with 40 hexadecimal characters, which is derived from the ECC public key. Capability: This an authorization capability which is set in the identity Manager smart contract. Capabilities associate granted permissions over a proxy address for a certain or indefinitely time. There are four defined capalibities (forward, devicemanager, admin and auth) Device authorization validation: Means verifying that a certain device(identified by a public key) has a capability to perform some action related to the Proxy contract. Identity Provider: This is the entity that helps users create their identities and more importantly helps to recover the user identity in case a user is not able to access its identity. Issue a credential: The process by which an issuer emits a verifiable credential on behalf of a user, the proof of validity is a signed range of time in which a hash (that represents a verifiable credential) is made available on a smart contract (Verification Registry).","title":"Key concepts and considerations"},{"location":"Tutorials/java-sdk/#requisites","text":"Java 8","title":"Requisites"},{"location":"Tutorials/java-sdk/#repository-url","text":"link here","title":"Repository URL"},{"location":"Tutorials/java-sdk/#what-can-i-do-with-this-sdk","text":"Identity creation for a user: This functionality can be in two steps: An Identity Provider creates an identity, the SDK goes to the blockchain and creates a new identity for you. As a result a decentralized identity is returned. Lets see it in a diagram: The provider associates the user's device address with the did obtained in the previous step. Note : Adding another device follows the exact process, but the did (that contains the smart contract proxy address) must be specified. In a later example this will be explained with an example. Device Autorization Validation: Check what a device can do (these are known as capabilities given to different devices). Issue a Verifiable Credential: Lets see what is the flow when this sdk generates a verifiable credential Check for a verifiable credential validity","title":"What can I do with this SDK?"},{"location":"Tutorials/java-sdk/#examples","text":"You can also find all examples in src/test into the packages: id.kaytrust.core.identity.ethereum id.kaytrust.core.verifiableCredential.ethereum Assumptions: A new user wants to deploy a new contract (Proxy contract) that represents its identity, the user will do this through the existing Identity Manager contract, it will create the Proxy and make the association between the user'\u015b device and the Proxy Contract.","title":"Examples"},{"location":"Tutorials/java-sdk/#previous-setting","text":"Setting an Identity Manager instance EthereumIdentityManager identityManager; String rpcConnection = \"http://eth-lacchain.kaytrust.id\"; //The ethereum node to access the Lacchain Network String IdentityManagerContractAddress = \"0xa6b4540a2bfbe8663caa78027c83d0dcb1b7c837\"; //This is the existing IdentityManager contract address String providerPrivateKey = \"0x9eb5a43839e8ff36fcdaed658136c51623be3af7de304d1c9181a6be9fac0863\"; //Provider private key { identityManager = new EthereumIdentityManagerImpl(); //Sets a new instance of IdentityManager to interact with. try { identityManager.instance(rpcConnection, providerPrivateKey, IdentityManagerContractAddress); } catch (Exception e) { e.printStackTrace(); } }","title":"Previous setting"},{"location":"Tutorials/java-sdk/#creating-a-new-identity-with-the-provider-key","text":"try{ System.out.println(\"*****************************************************************************\"); System.out.println(\"************************* Create Identity ********************************\"); String did = identityManager.createIdentity(); //Deploys a new Proxy Contract and sets Identity Provider private key // with all capabilities (it allows recovery functionalities) // Now verifying the did is not null boolean isTrue = !did.isEmpty(); System.out.println(\"Created DID: \" + did);//At this point only the identity provider has authorization over the proxy if (isTrue){ System.out.println(\"SUCCESS\"); } assertNotNull(did); }catch(Exception e){ e.printStackTrace(); fail(); } By creating an Identity a new did (decentralized identifier) is returned, this did has been associated with a provider address. At this point only the provider can add devices on behalf of a user. Associating a user's device address to the new proxy contract identity. try { System.out.println(\"*****************************************************************************\"); System.out.println(\"************************* Authorize Device *******************************\"); String devicePublicKey = \"fadb30ab306603e1806e1fbd324cf21aaefb32c8a1f3f4cf701f3eafd17df68e97ec33dd77d7d6e7dc436905dc47f2f3da907e3a3be05cce348d10d51323dd5e\"; identityManager.authorizeDevice(did, devicePublicKey, CapabilityEnum.FORWARD.description()); //Setting forward // capability, between the Proxy and the device, in the IdentityManager contract. System.out.println(\"SUCCESS\"); assertNotNull(did); } catch (Exception e) { System.out.println(\"FAILED\"); e.printStackTrace(); fail(); } Notes: Note that the identity Manager instance has been initialized with a private key that has all permissions over the deployed proxy, that is why it is possible to associate a new device with the Proxy contract. The association process can be repeated \"n\" times to add as many devices as requrired.","title":"Creating a new Identity with the provider key"},{"location":"Tutorials/java-sdk/#identity-validation","text":"Now that a new did has been created lets verify if the \"deviceA\" has the \"forward\" capability. Note the some variables which has been previously defined are been reused. try { EthereumIdentityConsumer identityConsumer=new EthereumIdentityConsumerImpl(); identityConsumer.instance(rpcConnection, null, identityManagerContractAddress); boolean isTrue = identityConsumer.isDeviceAuthorized(did, devicePublicKey,CapabilityEnum.FORWARD.description());//you can check other capabilities like FORWARD, AUTH or DEVICE_MANAGER if (isTrue){ System.out.println(\"SUCCESS\"); } assertTrue(isTrue); } catch (Exception e) { e.printStackTrace(); fail(); }","title":"Identity Validation"},{"location":"Tutorials/java-sdk/#issuing-a-credential","text":"Setting a Subject example class definition: //Setting a Subject example class definition: class CredentialSubject { @SerializedName(\"@id\") String id; String name; String birthDate; } //Defining general variables before executing examples related to credential issuance String issuerPrivateKey; EthereumCredentialIssuer credentialIssuer; { String verificationRegistryContractAddress = \"0x9f8c1e196F5696e014F4d1E4961B92db866BE271\"; credentialIssuer = new EthereumCredentialIssuerImpl(); try { issuerPrivateKey = \"0x9eb5a43839e8ff36fcdaed658136c51623be3af7de304d1c9181a6be9fac0863\"; credentialIssuer.instance(rpcConnection, issuerPrivateKey, verificationRegistryContractAddress); } catch (Exception e) { e.printStackTrace(); } } Issuance process: public void issueCredential() { System.out.println(\"*****************************************************************************\"); System.out.println(\"************************* Credential Issuance *******************************\"); try { String subject = \"{\" + \"\\\"@id\\\":\" + \"\\\"did:ev:cwMLLiMQGm9EaTqzY2k58refSoXdTsYvJ9Znp\\\",\" + \"\\\"name\\\":\\\"John Doe\\\",\" + \"\\\"birthDate\\\":\\\"2018-01-01\\\"}\"; CredentialSubject sc = new Gson().fromJson(subject, CredentialSubject.class); String[] credentialType = { \"VerifiableCredential\", \"MyCustomType\" }; String vc = credentialIssuer.issueCredential(sc, credentialType, null, null, new EthereumAttestation2019Builder(), null); log.info(\"verificationCredential :\\n {} \",vc); if (!vc.isEmpty()){ log.info(\"SUCCESS\"); } assertNotNull(vc); } catch (Exception e) { e.printStackTrace(); fail(); } }","title":"Issuing a credential"},{"location":"Tutorials/java-sdk/#checking-for-a-verifiable-credential-validity","text":"Previous setting EthereumCredentialValidation credentialValidation; { System.out.println(\"********************** Credential ValidationTest - Previous Setting ****************************\"); credentialValidation = new EthereumCredentialValidationImpl(); try { credentialValidation.instance(rpcConnection, issuerPrivateKey, verificationRegistryContractAddress, new EthereumAttestation2019Builder()); System.out.println(\"Verifiable credential is: \" + vc + \"\\nIssued by \" + (EthereumKeyUtils.getAddressFromPrivateKey(issuerPrivateKey))); } catch (Exception e) { e.printStackTrace(); } } It is time to check if a verifiable credential is valid or not, by checking if an issuer has registered a credential hash on the Verification Registry contract public void credentialCheckingTest() { System.out.println(\"*****************************************************************************\"); System.out.println(\"********************** Credential ValidationTest ****************************\"); try { System.out.println(\"Verifying \" + (EthereumKeyUtils.getAddressFromPrivateKey(issuerPrivateKey)) +\" has emitted the verifiable credential and also the verifiable credential is not expired...\"); //Note that it is not necessary to have the private key but only the issuer address. boolean isValidCredential = credentialValidation.verifyCredential(vc);//returns \"true\" if the verifiable credential is valid; otherwise \"false\"; //in this case we are simply using the verifiable credential that was returned in the previous step. if (isValidCredential){ log.info(\"SUCCESS\"); } assertTrue(isValidCredential); } catch (Exception e) { e.printStackTrace(); fail(); } }","title":"Checking for a Verifiable credential validity"}]}