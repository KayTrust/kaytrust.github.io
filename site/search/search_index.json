{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"KayTrust Developer Space What is KayTrust? KayTrust is a complete digital identity solution comprised of: A set of technical specifications around self-sovereign identity based on Internet standards Reference implementations: An SDK (currently for Java and Javascript/NodeJS) to make implementation easier for developers. Ready-to-use software built on top of the libraries: KayTrust Wallet . A mobile Wallet for users (free of charge). KayTrust Provider . An enterprise server suite for organisations that wish to issue and manage credentials with minimal effort. The purpose of this space is to make life easy for developers. You will eventually find specifications, library references, tutorials and examples on how to use the core libraries, as well as manuals to install, configure, use and extend KayTrust Provider and KayTrust Wallet. Not all the documentation is available yet at this developer space is new, so please bear with us! KayTrust Stack What does Digital Identity mean? Identity refers to 2 things: Identifiers , i.e. unique and non-ambiguous strings used to refer to people, organizations, vehicles, building, etc. An email address, a phone number, a national ID number, a nickname or a physical address are all identifiers within a certain system. Claims , i.e. what is said about those entities. It's also usually important to consider who says those things. For example \"Individual with ID number 123 can drive\" is useless without the information (and proof) of who claims it \u2013 typically a government entity. A set of claims, packed along with an issuing entity's identifier and a way to verify the whole thing, is called a credential . The vision of decentralised digital identity It is important to understand the vision behind self-sovereign identity: nobody (no company, not any government, etc.) may control, block, censure, delete or spoof users' identity, restrict what users may do with their identity, or access information that users didn't agree to share. KayTrust achieves that by using a decentralised trust repository (typically a blockchain) for identifiers, for credential proofs, and for sharing consent. The repository itself only stores proofs of data integrity. No private information is stored on the shared repository, so KayTrust works on public repositories such as public blockchains. For more information, please visit kaytrust.id .","title":"Home"},{"location":"#kaytrust-developer-space","text":"","title":"KayTrust Developer Space"},{"location":"#what-is-kaytrust","text":"KayTrust is a complete digital identity solution comprised of: A set of technical specifications around self-sovereign identity based on Internet standards Reference implementations: An SDK (currently for Java and Javascript/NodeJS) to make implementation easier for developers. Ready-to-use software built on top of the libraries: KayTrust Wallet . A mobile Wallet for users (free of charge). KayTrust Provider . An enterprise server suite for organisations that wish to issue and manage credentials with minimal effort. The purpose of this space is to make life easy for developers. You will eventually find specifications, library references, tutorials and examples on how to use the core libraries, as well as manuals to install, configure, use and extend KayTrust Provider and KayTrust Wallet. Not all the documentation is available yet at this developer space is new, so please bear with us!","title":"What is KayTrust?"},{"location":"#kaytrust-stack","text":"","title":"KayTrust Stack"},{"location":"#what-does-digital-identity-mean","text":"Identity refers to 2 things: Identifiers , i.e. unique and non-ambiguous strings used to refer to people, organizations, vehicles, building, etc. An email address, a phone number, a national ID number, a nickname or a physical address are all identifiers within a certain system. Claims , i.e. what is said about those entities. It's also usually important to consider who says those things. For example \"Individual with ID number 123 can drive\" is useless without the information (and proof) of who claims it \u2013 typically a government entity. A set of claims, packed along with an issuing entity's identifier and a way to verify the whole thing, is called a credential .","title":"What does Digital Identity mean?"},{"location":"#the-vision-of-decentralised-digital-identity","text":"It is important to understand the vision behind self-sovereign identity: nobody (no company, not any government, etc.) may control, block, censure, delete or spoof users' identity, restrict what users may do with their identity, or access information that users didn't agree to share. KayTrust achieves that by using a decentralised trust repository (typically a blockchain) for identifiers, for credential proofs, and for sharing consent. The repository itself only stores proofs of data integrity. No private information is stored on the shared repository, so KayTrust works on public repositories such as public blockchains. For more information, please visit kaytrust.id .","title":"The vision of decentralised digital identity"},{"location":"Manuals/","text":"Identity Contracts Introduction This section is intended to guide you through all the functionalities offered by the Identity contracts. First, lets recap the types of contracts and how they are related and finally explore what we can do with them. Considerations In the current state contracts are available for ethereum networks. General assumptions Device: This document supposes a user/entity accessing the contract through any device like a computer, mobile phone, tablet, IoT device, remote server. Later in this document the term device refers to any of the mentioned here. User: The end user who creates its identity either through the IndetityManager or direclty by deploying an instance of the proxy smart contract. Types of contracts Two contracts are used in order to create and manage identities. Proxy contract The Proxy smart contract represents the Identity for a specific person . This contract Allows to: Set one or more ethereum addresses as the owner/owners of a proxy instance. Allows to forward any message to any other contract in the network where the proxy contract has been deployed. You are totally free to deploy a proxy contract instance without depending of any other contract. When it is done you can set an address as the owner of that contract. Another way to deploy a proxy instance is by using an Identity Manager contract. The identity manager is explained in the next section. Forward any message to any other contract. This is the main method in this contract. Interested to see all the details about the Proxy contract?. Please refer to the following documentation Identity Manager contract This contract is aimed to be used as a layer of abstraction when making actions related to your identity. Later in this document called IM. This contract is not owned or administered by anyone . Authorization levels in the Identity Manager Contract The following authorization levels are currently supported in the Identity Manager contract: Those levels can be applied to any device with a configured private key. fw: Allows the device to forward messages through the IdentityManager contract. auth: If assigned to a certain device you can create an offline logic that includes querying to the IM contract if the device has authentication capabilities; it allows developers perform authentication processes. devicemanager: Allows to add a new device from which the user can access to its identity. admin: A user with this capability is able to transfer its proxy identity to a new IdentityManager. Available actions in the Identity Manager Those actions can be categorized in three groups: Identity lifecycle thorugh the Identity manager Identity creation reference Register/remove devices to interact with their identities which live on the blockchain reference Transfer identity management to a new IdentityManager reference Identity recovery Administrative actions Add/Remove capabilities to a device reference Check capabilities a certain device is granted in the Identity Manager Contract. reference Forward messages through the IdentityManager: The identity Manager serves as a proxy to deliver messages to any existing contract in the netwwork when the Identity Manager contract lives. reference Identity Manager contract deployment The IdentityManager contract can have many flavours. In this version we use solidity in order to make it deployable on ethereum networks. As a developer who want to use the Kaytrust solution you don not need to deploy the IdentityManager contract , instead simply consume its methods though our available Kaytrust SDKs: Kaytrust Java SDK","title":"Manuals"},{"location":"Manuals/#identity-contracts","text":"","title":"Identity Contracts"},{"location":"Manuals/#introduction","text":"This section is intended to guide you through all the functionalities offered by the Identity contracts. First, lets recap the types of contracts and how they are related and finally explore what we can do with them.","title":"Introduction"},{"location":"Manuals/#considerations","text":"In the current state contracts are available for ethereum networks.","title":"Considerations"},{"location":"Manuals/#general-assumptions","text":"Device: This document supposes a user/entity accessing the contract through any device like a computer, mobile phone, tablet, IoT device, remote server. Later in this document the term device refers to any of the mentioned here. User: The end user who creates its identity either through the IndetityManager or direclty by deploying an instance of the proxy smart contract.","title":"General assumptions"},{"location":"Manuals/#types-of-contracts","text":"Two contracts are used in order to create and manage identities.","title":"Types of contracts"},{"location":"Manuals/#proxy-contract","text":"The Proxy smart contract represents the Identity for a specific person . This contract Allows to: Set one or more ethereum addresses as the owner/owners of a proxy instance. Allows to forward any message to any other contract in the network where the proxy contract has been deployed. You are totally free to deploy a proxy contract instance without depending of any other contract. When it is done you can set an address as the owner of that contract. Another way to deploy a proxy instance is by using an Identity Manager contract. The identity manager is explained in the next section. Forward any message to any other contract. This is the main method in this contract. Interested to see all the details about the Proxy contract?. Please refer to the following documentation","title":"Proxy contract"},{"location":"Manuals/#identity-manager-contract","text":"This contract is aimed to be used as a layer of abstraction when making actions related to your identity. Later in this document called IM. This contract is not owned or administered by anyone .","title":"Identity Manager contract"},{"location":"Manuals/#authorization-levels-in-the-identity-manager-contract","text":"The following authorization levels are currently supported in the Identity Manager contract: Those levels can be applied to any device with a configured private key. fw: Allows the device to forward messages through the IdentityManager contract. auth: If assigned to a certain device you can create an offline logic that includes querying to the IM contract if the device has authentication capabilities; it allows developers perform authentication processes. devicemanager: Allows to add a new device from which the user can access to its identity. admin: A user with this capability is able to transfer its proxy identity to a new IdentityManager.","title":"Authorization levels in the Identity Manager Contract"},{"location":"Manuals/#available-actions-in-the-identity-manager","text":"Those actions can be categorized in three groups: Identity lifecycle thorugh the Identity manager Identity creation reference Register/remove devices to interact with their identities which live on the blockchain reference Transfer identity management to a new IdentityManager reference Identity recovery Administrative actions Add/Remove capabilities to a device reference Check capabilities a certain device is granted in the Identity Manager Contract. reference Forward messages through the IdentityManager: The identity Manager serves as a proxy to deliver messages to any existing contract in the netwwork when the Identity Manager contract lives. reference","title":"Available actions in the Identity Manager"},{"location":"Manuals/#identity-manager-contract-deployment","text":"The IdentityManager contract can have many flavours. In this version we use solidity in order to make it deployable on ethereum networks. As a developer who want to use the Kaytrust solution you don not need to deploy the IdentityManager contract , instead simply consume its methods though our available Kaytrust SDKs: Kaytrust Java SDK","title":"Identity Manager contract deployment"},{"location":"Specs/","text":"KayTrust Specifications Core identity KayTrust uses the standard DID protocol for identifiers, and defines a \"gid\" DID method based on smart contracts . Specification Builds on top of What is it good for? \"ev\" DID method W3C's DID Specification Ethereum-based DIDs Proxy contract ERC Ethereum Transaction forwarding, on-chain representation, single Ethereum addresses Identity Manager ERC Ethereum Flexible controlling logic for Proxy contracts Verifiable credentials and Presentations Besides identifiers, the point of an identity is to have credentials associated to it. A credential answers the question \"Who are you?\" and contains one or more key-value claims (e.g. birth date, name, qualifications, citizenships, etc.) about an entity called subject, issued by another entity called issuer. The Verifiable Credentials Working Group at the W3C is defining a standard that KayTrust follows. Both Verifiable Credentials (VC) and Verifiable Presentations (VP) contain proofs, which is what makes them verifiable. The VC specification doesn't enforce a specific proof algorithm but describes the articulation between a credential/presentation and a specific proof method. Implementers are free to come up with their own proof method or to follow someone else's. The draft ERC (Ethereum Request for Comments) describes a way for any entity to attest arbitrary content on a smart contract. There is a corresponding proof type that enables to use that attestation registry inside a Verifiable Credential or a Verifiable Presentation. Specification Builds on top of What is it good for? Content Attestation Registry ERC Ethereum Attesting any kind of content on-chain Attestation Registry VC proof type W3C's Verifiable Credentials Specification Using a Content Attestation Registry as proof of a VC or a VP Real-world, self-sovereign authentication: \"DID Connect\" KayTrust introduces a way for identity owners (a.k.a. subjects) to authenticate on third-party apps. We propose using OpenID Connect, only in a self-sovereign fashion. The trick is to use as Authorization Server the identity owner's own device, as opposed to a predefined AS in traditional services. Specification Builds on top of What is it good for? DIDConnect OIDC Profile OpenID Connect Self-sovereign use of OpenID Connect Schemas KayTrust mostly relies on well-known schemas, such as the great work done by the schema.org community. However, when the need arises, additional schemas are defined. Schema Purpose Trusted Credentials Chain of Trust for Verifiable Credentials Why did you need to define anything? Websites , electronic mail (email), email addresses , TCP connections , IP addresses , URLs , HTML pages , JPEG . Those are known and mature concepts. Passwords , cryptographic keys , digital signatures , unique identifiers . Also mature concepts. Likes , tweets , cookies , browser-side scripts , user profiles. Those are a bit younger but also well known. Blockchain . Verifiable credentials . Digital identity . Now we're talking about something more recent in the history of internet. Those concepts are slowly taking shape, paving their way into users' and developers' minds, and into standards organizations' discussions. RFCs are being written, W3C Working Groups are being set up, blog articles are being cited. Since digital identity is both a young a wide domain, KayTrust's objective is to bind together the state of the art of digital identity standards and turn them into a usable package for people and for businesses.","title":"Specs"},{"location":"Specs/#kaytrust-specifications","text":"","title":"KayTrust Specifications"},{"location":"Specs/#core-identity","text":"KayTrust uses the standard DID protocol for identifiers, and defines a \"gid\" DID method based on smart contracts . Specification Builds on top of What is it good for? \"ev\" DID method W3C's DID Specification Ethereum-based DIDs Proxy contract ERC Ethereum Transaction forwarding, on-chain representation, single Ethereum addresses Identity Manager ERC Ethereum Flexible controlling logic for Proxy contracts","title":"Core identity"},{"location":"Specs/#verifiable-credentials-and-presentations","text":"Besides identifiers, the point of an identity is to have credentials associated to it. A credential answers the question \"Who are you?\" and contains one or more key-value claims (e.g. birth date, name, qualifications, citizenships, etc.) about an entity called subject, issued by another entity called issuer. The Verifiable Credentials Working Group at the W3C is defining a standard that KayTrust follows. Both Verifiable Credentials (VC) and Verifiable Presentations (VP) contain proofs, which is what makes them verifiable. The VC specification doesn't enforce a specific proof algorithm but describes the articulation between a credential/presentation and a specific proof method. Implementers are free to come up with their own proof method or to follow someone else's. The draft ERC (Ethereum Request for Comments) describes a way for any entity to attest arbitrary content on a smart contract. There is a corresponding proof type that enables to use that attestation registry inside a Verifiable Credential or a Verifiable Presentation. Specification Builds on top of What is it good for? Content Attestation Registry ERC Ethereum Attesting any kind of content on-chain Attestation Registry VC proof type W3C's Verifiable Credentials Specification Using a Content Attestation Registry as proof of a VC or a VP","title":"Verifiable credentials and Presentations"},{"location":"Specs/#real-world-self-sovereign-authentication-did-connect","text":"KayTrust introduces a way for identity owners (a.k.a. subjects) to authenticate on third-party apps. We propose using OpenID Connect, only in a self-sovereign fashion. The trick is to use as Authorization Server the identity owner's own device, as opposed to a predefined AS in traditional services. Specification Builds on top of What is it good for? DIDConnect OIDC Profile OpenID Connect Self-sovereign use of OpenID Connect","title":"Real-world, self-sovereign authentication: \"DID Connect\""},{"location":"Specs/#schemas","text":"KayTrust mostly relies on well-known schemas, such as the great work done by the schema.org community. However, when the need arises, additional schemas are defined. Schema Purpose Trusted Credentials Chain of Trust for Verifiable Credentials","title":"Schemas"},{"location":"Specs/#why-did-you-need-to-define-anything","text":"Websites , electronic mail (email), email addresses , TCP connections , IP addresses , URLs , HTML pages , JPEG . Those are known and mature concepts. Passwords , cryptographic keys , digital signatures , unique identifiers . Also mature concepts. Likes , tweets , cookies , browser-side scripts , user profiles. Those are a bit younger but also well known. Blockchain . Verifiable credentials . Digital identity . Now we're talking about something more recent in the history of internet. Those concepts are slowly taking shape, paving their way into users' and developers' minds, and into standards organizations' discussions. RFCs are being written, W3C Working Groups are being set up, blog articles are being cited. Since digital identity is both a young a wide domain, KayTrust's objective is to bind together the state of the art of digital identity standards and turn them into a usable package for people and for businesses.","title":"Why did you need to define anything?"},{"location":"Tutorials/","text":"Tutorials About this section In this section, you will be able to find tutorials to help you use KayTrust As a DApp developer (WIP) As a backend developer Java SDK","title":"Tutorials"},{"location":"Tutorials/#tutorials","text":"","title":"Tutorials"},{"location":"Tutorials/#about-this-section","text":"In this section, you will be able to find tutorials to help you use KayTrust As a DApp developer (WIP) As a backend developer Java SDK","title":"About this section"},{"location":"about/","text":"Componentes For full documentation visit mkdocs.org . Protocolos mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. SDK Java mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. SDK JS mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. KayTrust Hub mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. KayTrust Provider mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files. KayTrust Wallet mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Componentes"},{"location":"about/#componentes","text":"For full documentation visit mkdocs.org .","title":"Componentes"},{"location":"about/#protocolos","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Protocolos"},{"location":"about/#sdk-java","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"SDK Java"},{"location":"about/#sdk-js","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"SDK JS"},{"location":"about/#kaytrust-hub","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"KayTrust Hub"},{"location":"about/#kaytrust-provider","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"KayTrust Provider"},{"location":"about/#kaytrust-wallet","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"KayTrust Wallet"},{"location":"download/","text":"Donwloads KayTrust Wallet ...... Version Estable Version 12.0.4 Disponible en la PlayStore de Android Disponible en la MarketPlace de IOS Releases Version 12.0.1 Version 10.0.1","title":"Donwloads"},{"location":"download/#donwloads","text":"KayTrust Wallet ......","title":"Donwloads"},{"location":"download/#version-estable","text":"Version 12.0.4 Disponible en la PlayStore de Android Disponible en la MarketPlace de IOS","title":"Version Estable"},{"location":"download/#releases","text":"Version 12.0.1 Version 10.0.1","title":"Releases"},{"location":"join/","text":"Unete Para unirte a la comunidad mas grande de la Region ingresa al siguiente link kaytrust.id . Training Virtual In construction .. Eventos In construction .. Conferencias In construction .. Noticias In construction ..","title":"Unete"},{"location":"join/#unete","text":"Para unirte a la comunidad mas grande de la Region ingresa al siguiente link kaytrust.id .","title":"Unete"},{"location":"join/#training-virtual","text":"In construction ..","title":"Training Virtual"},{"location":"join/#eventos","text":"In construction ..","title":"Eventos"},{"location":"join/#conferencias","text":"In construction ..","title":"Conferencias"},{"location":"join/#noticias","text":"In construction ..","title":"Noticias"},{"location":"products/","text":"Productos El activo KayTrust cuenta con los siguientes productos: Protocolos de Identidad Identidad Digital SDK Hub SDK Provider KayTrust Hub KayTrust Provider KayTrust Wallet Protocolos de Identidad Proxy Contract .... Proxy Type .... Identidad Digital KayTrust Digital Identity - Proveedor de Identidad Digital .......... .......... Digital Identity - Dependencias Usando MAVEN <dependency> <groupId>com.everis.blockchain</groupId> <artifactId>algorithm</artifactId> <version>0.0.4</version> </dependency> O descargandote las librerias de la siguiente URL : [AzureRepos.id](https://azurerepos.id/). Digital Identity - Clases * Crear Credenciales ... .. * Crear Contrato * .... Digital Identity - Demo Crear Credenciales * Importar librerias package demo.acme.kaytrust import com.everis.blockchain.algorithm.web3j.html.Account; import com.everis.blockchain.algorithm.web3j.html.EthCore; import com.everis.blockchain.algorithm.web3j.html.EthCoreParams; public class GeneratePrivateKey { private static final Logger log = LoggerFactory.getLogger(\"GeneratePrivateKey\"); public void create() throws Exception { Account account = ethCore.createCredentials(\"\"); log.info(\"PRIVATE_KEY_BACKEND : \" + account.getPrivateKey()); log.info(\"ADDRESS_ETHEREUM_BACKEND : \" + account.getAddress()); } } SDK Hub In construction .. SDK Provider In construction .. KayTrust Hub In construction .. KayTrust Provider In construction .. KayTrust Wallet In construction ..","title":"Productos"},{"location":"products/#productos","text":"El activo KayTrust cuenta con los siguientes productos: Protocolos de Identidad Identidad Digital SDK Hub SDK Provider KayTrust Hub KayTrust Provider KayTrust Wallet","title":"Productos"},{"location":"products/#protocolos-de-identidad","text":"Proxy Contract .... Proxy Type ....","title":"Protocolos de Identidad"},{"location":"products/#identidad-digital","text":"KayTrust Digital Identity - Proveedor de Identidad Digital .......... .......... Digital Identity - Dependencias Usando MAVEN <dependency> <groupId>com.everis.blockchain</groupId> <artifactId>algorithm</artifactId> <version>0.0.4</version> </dependency> O descargandote las librerias de la siguiente URL : [AzureRepos.id](https://azurerepos.id/). Digital Identity - Clases * Crear Credenciales ... .. * Crear Contrato * .... Digital Identity - Demo Crear Credenciales * Importar librerias package demo.acme.kaytrust import com.everis.blockchain.algorithm.web3j.html.Account; import com.everis.blockchain.algorithm.web3j.html.EthCore; import com.everis.blockchain.algorithm.web3j.html.EthCoreParams; public class GeneratePrivateKey { private static final Logger log = LoggerFactory.getLogger(\"GeneratePrivateKey\"); public void create() throws Exception { Account account = ethCore.createCredentials(\"\"); log.info(\"PRIVATE_KEY_BACKEND : \" + account.getPrivateKey()); log.info(\"ADDRESS_ETHEREUM_BACKEND : \" + account.getAddress()); } }","title":"Identidad Digital"},{"location":"products/#sdk-hub","text":"In construction ..","title":"SDK Hub"},{"location":"products/#sdk-provider","text":"In construction ..","title":"SDK Provider"},{"location":"products/#kaytrust-hub","text":"In construction ..","title":"KayTrust Hub"},{"location":"products/#kaytrust-provider","text":"In construction ..","title":"KayTrust Provider"},{"location":"products/#kaytrust-wallet","text":"In construction ..","title":"KayTrust Wallet"},{"location":"Manuals/IM/IM_recover_identity/","text":"Recover your identity Lets imagine the situation where you no longer can access your device(s). In such scenario you can still recover your identity. In order to perform this process you can set a trusted third party with an \"devicemanager\" capability. In case of \"disaster\" scenarios you can contact the third party which after an offline check process can set a new device(\"newdevice\") through the \"adding a new device process\" explained above; after that you can access your already blockchain existing identity with your \"newdevice\". As a product Kaytrust (a trusted third party) has a set of tools that can help you benefit of the user friendly interfaces to guide you in this process.","title":"Recover your identity"},{"location":"Manuals/IM/IM_recover_identity/#recover-your-identity","text":"Lets imagine the situation where you no longer can access your device(s). In such scenario you can still recover your identity. In order to perform this process you can set a trusted third party with an \"devicemanager\" capability. In case of \"disaster\" scenarios you can contact the third party which after an offline check process can set a new device(\"newdevice\") through the \"adding a new device process\" explained above; after that you can access your already blockchain existing identity with your \"newdevice\". As a product Kaytrust (a trusted third party) has a set of tools that can help you benefit of the user friendly interfaces to guide you in this process.","title":"Recover your identity"},{"location":"Manuals/diagrams/administration/IM_identity_administration/","text":"Administrative capabilities Adding/removing capabilities to an existing device Adding/removing capabilities to an exiting device follows the exact process as adding a new device. Check user device permissions level Checking user's device permission level is as simple as executing a call to the \"hasCap\" method in the Identity Manager that administers your proxy contract.","title":"Administrative capabilities"},{"location":"Manuals/diagrams/administration/IM_identity_administration/#administrative-capabilities","text":"","title":"Administrative capabilities"},{"location":"Manuals/diagrams/administration/IM_identity_administration/#addingremoving-capabilities-to-an-existing-device","text":"Adding/removing capabilities to an exiting device follows the exact process as adding a new device.","title":"Adding/removing capabilities to an existing device"},{"location":"Manuals/diagrams/administration/IM_identity_administration/#check-user-device-permissions-level","text":"Checking user's device permission level is as simple as executing a call to the \"hasCap\" method in the Identity Manager that administers your proxy contract.","title":"Check user device permissions level"},{"location":"Manuals/diagrams/forward/forward/","text":"Forwarding though the IdentityManager Through the IdentityManager contract(AcmeIdentityManager) you are also able to forward transactions to any other contract, for that when you invoke AcmeIdentityManager to forward transactions it will make some verifications and then pass this message to your proxy contract (JhonProxy) which will make some verifications before reaching the desired contract. To clarify this, lets see a diagram to illustrate this flow:","title":"Forwarding though the IdentityManager"},{"location":"Manuals/diagrams/forward/forward/#forwarding-though-the-identitymanager","text":"Through the IdentityManager contract(AcmeIdentityManager) you are also able to forward transactions to any other contract, for that when you invoke AcmeIdentityManager to forward transactions it will make some verifications and then pass this message to your proxy contract (JhonProxy) which will make some verifications before reaching the desired contract. To clarify this, lets see a diagram to illustrate this flow:","title":"Forwarding though the IdentityManager"},{"location":"Manuals/diagrams/identity-lifecycle/IM_add_remove_device/","text":"Adding another device Lets assume John wants to add another device (JohnDeviceB) from which he can control his identity operations. Adding such device is as simple as giving it the desired capability(forward, device manager, admin or proxy). The next diagram shows what is the flow to achieve that: As shown in the prevous diagram, a new device has been added on behalf of John. Only \"deviceManager\" granted roles can authorize other devices. Because \"device B\" has \"deviceManager\" capability then it can grant any authorization level on behalf of John. Removing a device is similar to the adding process. The difference lies in the argument time, that is set a time less than the current time. For more information please check the setCap method in the IdentityManager contract.","title":"Adding another device"},{"location":"Manuals/diagrams/identity-lifecycle/IM_add_remove_device/#adding-another-device","text":"Lets assume John wants to add another device (JohnDeviceB) from which he can control his identity operations. Adding such device is as simple as giving it the desired capability(forward, device manager, admin or proxy). The next diagram shows what is the flow to achieve that: As shown in the prevous diagram, a new device has been added on behalf of John. Only \"deviceManager\" granted roles can authorize other devices. Because \"device B\" has \"deviceManager\" capability then it can grant any authorization level on behalf of John. Removing a device is similar to the adding process. The difference lies in the argument time, that is set a time less than the current time. For more information please check the setCap method in the IdentityManager contract.","title":"Adding another device"},{"location":"Manuals/diagrams/identity-lifecycle/IM_identity_creation/","text":"Creating an identity for a user through the IdentityManager Contract Assumptions: In order to show how to interact with the IdentityManager contract assume an already deployed instance of that and lets call it AcmeIdentityManager. Now thorugh this contract many users can deploy their identities. Lets say John have a device (JohnDeviceA), he wants to create his identity and register a device in order to use it to execute actions related to his identity. Lets see what is the flow to do that. At the end John has created a Proxy contract (JhonProxy). ProxyA represents John's identity. So from now, all actions performed by John through its device (JohnDeviceA) will be executed through JohnProxy. Note how the identity manager facilitates this process by setting up all what is needed an simply returning the proxy contract address to John. When setting the first device (JohnDeviceA) it has all the capabilities. Now John can access its JhonProxy identity through AcmeIdentityManager.","title":"Creating an identity for a user through the IdentityManager Contract"},{"location":"Manuals/diagrams/identity-lifecycle/IM_identity_creation/#creating-an-identity-for-a-user-through-the-identitymanager-contract","text":"Assumptions: In order to show how to interact with the IdentityManager contract assume an already deployed instance of that and lets call it AcmeIdentityManager. Now thorugh this contract many users can deploy their identities. Lets say John have a device (JohnDeviceA), he wants to create his identity and register a device in order to use it to execute actions related to his identity. Lets see what is the flow to do that. At the end John has created a Proxy contract (JhonProxy). ProxyA represents John's identity. So from now, all actions performed by John through its device (JohnDeviceA) will be executed through JohnProxy. Note how the identity manager facilitates this process by setting up all what is needed an simply returning the proxy contract address to John. When setting the first device (JohnDeviceA) it has all the capabilities. Now John can access its JhonProxy identity through AcmeIdentityManager.","title":"Creating an identity for a user through the IdentityManager Contract"},{"location":"Manuals/diagrams/identity-lifecycle/IM_migration_to_new_IM/","text":"Migrating to a new IdentityManager Lets imagine the situation when users want to migrate to a new IdentityManager, such scenario is totally feasible. In order to exemplify this, assume John as an identity that was created using Acme Identity Manager contract but something happened and he decides to migrate to a new Identity Manager contract lets name this CorpIM. The following diagram shows the logical flow when a new IdentityManager replaces an old one. As shown in the prevous diagram, a new IdentityManager (CorpIM) has replaced an old one (AcmeIM) It is worth to say that only devices with the ADMINISTRATOR capability, can perform this action.","title":"Migrating to a new IdentityManager"},{"location":"Manuals/diagrams/identity-lifecycle/IM_migration_to_new_IM/#migrating-to-a-new-identitymanager","text":"Lets imagine the situation when users want to migrate to a new IdentityManager, such scenario is totally feasible. In order to exemplify this, assume John as an identity that was created using Acme Identity Manager contract but something happened and he decides to migrate to a new Identity Manager contract lets name this CorpIM. The following diagram shows the logical flow when a new IdentityManager replaces an old one. As shown in the prevous diagram, a new IdentityManager (CorpIM) has replaced an old one (AcmeIM) It is worth to say that only devices with the ADMINISTRATOR capability, can perform this action.","title":"Migrating to a new IdentityManager"},{"location":"Specs/Content-Attestation-Registry-ERC/","text":"eip: <to be assigned> title: ERC: Content Attestation Registry author: David Ammouial (@davux) <dammouia@everis.com> discussions-to: <URL> status: Draft type: Standards Track category: ERC created: 2019-03-29 Simple Summary A generic and privacy-aware registry of attested information. Abstract This ERC describes a way for any entity to express and record its agreement with a given content, independently from the type of content, by storing a hash on chain along with a validity time range. Even though the existence of the agreement itself is provable and non-ambiguous, this specification doesn't place any semantics on the type of original content, how it's hashed, or what it means to agree with it. Likewise, it doesn't define any recommendation on the semantic validity of an attestation in relation to its recorded time range. As with any kind of recorded agreement, it is generally a good idea for the involved parties to ensure a mutual understanding on what is agreed upon and to what extent. This ERC also allows the agreeing party to amend a previously recorded attestation by redefining the validity time range (including retracting the attestation altogether). Motivation Traditionally, attesting to some kind of content is done through static signatures, e.g. a base64-encoded embedded RSA signature or a PGP signature. As for the smart contract world, hashes are often used in functions to certify content approval but no stable interface has been defined. This EIP is an attempt to homogenize a common interface for agreement that interoperable contract-based and web-based applications may start benefitting from. Also, traditional signatures, in order to be retracted or amended, need to be put in context of Certificate Revocation Lists (CRLs) or similar mechanisms. This EIP attempts to leverage blockchain technology to remove the need for such centralized databases. Definitions Attester The attester of a given content is any entity, represented by an Ethereum address, that records its agreement with that content. Attestation In this specification, an attestation is defined as a (start time, end time) tuple that represents the time range during which a content is agreed upon by a specific attester. Verifier The verifier of an attestation is an entity going through the process of reading an attestation for a given content and making conclusions on whether to trust that content. Specification The general idea of this EIP is that attesting a given content is equivalent to attesting a hash of that content, as long as the hashing function is known by the attester and the verifier. An attestation is recorded as an (iat, exp) tuple, where iat (\"issued at\") is the time the attestation starts to be valid, and exp (\"expires\") is the time after which the attestation is no longer valid. Note the special meaning of the following values: iat == 0 means the attester is NOT currently attesting to that content. In this case, the value of exp is irrelevant. Per Solidity rules, this is the initial value for any attestation. Its intended usage inside the attest() function is to explicitly revoke an existing (i.e. non-zero iat ) attestation. exp == 0 means the attester is not currently placing any expiration time on the attestation. Just like any other value, a value of 0 may be amended later if the attester decides so. This EIP defines the following functions: attest Used in a transaction to record an (iat, exp) attestation of a given hash. function attest(bytes32 hash, uint iat, uint exp) public; attestations Used to read the most recent attestation, if any, of a given hash , recorded by a given attester . Its return value is an (iat, exp) tuple. function attestations(bytes32 hash, address attester) public; This EIP defines the following event: Verified This event is emitted everytime a hash is attested or revoked by an attester and contains the iat and exp times of the attestation. A value of 0 for iat means any previous attestation is being revoked. The event may be emitted with any values for iat and exp , including values equal to the previous ones (for example an already revoked attestation may be revoked again, or an attestation may be attested again with the same values). event Verified(bytes32 indexed hash, address attester, uint iat, uint exp); Note about validity times The validity time range is a mere indication by the attester. This EIP does not define what policy should be applied by verifying software or people with respect to current time. Here are a few real-life policy examples: Safe policy . Some verifiers might decide that an attestation is only acceptable if the expiration time is at least 6 months in the future. Flexible policy . Some verifiers might leave a tolerance window during which they still accept an expired attestation. Strict policy . Some verifiers might only accept an attestation during the attestation time range. Some verifiers might apply more complex policies, e.g. where the tolerance depends on the identity of the attester, on the content, on the actual transaction time of the attestation, on the existence of previous attestations, etc. Rationale Storing validity times on-chain vs. off-chain Information stored on a blockchain is both public and permanent, which makes it a crucial decision to decide what to store and what not to store. For this reason, a balance should always be seeked between privacy and usefulness. Specifically, the decision to include validity times on chain rather than in the original content is a result of that subjective balance: Including validity times means leaking out information allowing to suspect or discard specific contents for a given hash. For example, time ranges of 3 weeks might give up certain types of documents, and exclude e.g. passports. Leaving validity times off-chain (typically in the original document) might not work very well for some types of documents where the issuer and the attester are separate entities and the attester doesn't have the liberty to emit an \"attestation document\" containing validity times. This specification allows verifiers to store date information on-chain. However, the attester and the verifier are always free to use any non-zero value in the (iat, exp) tuple and maintain date information off-chain instead. Attesting hashes vs. plain data To follow best practices, it was deemed equally secure, cheaper, and most respectful to privacy to record fixed-length bytes32 data rather than actual content. Backwards Compatibility This EIP doesn't introduce any known backwards compatibility issues. Implementation An implementation may be found here . Copyright Copyright and related rights waived via CC0 .","title":"Content Attestation Registry ERC"},{"location":"Specs/Content-Attestation-Registry-ERC/#simple-summary","text":"A generic and privacy-aware registry of attested information.","title":"Simple Summary"},{"location":"Specs/Content-Attestation-Registry-ERC/#abstract","text":"This ERC describes a way for any entity to express and record its agreement with a given content, independently from the type of content, by storing a hash on chain along with a validity time range. Even though the existence of the agreement itself is provable and non-ambiguous, this specification doesn't place any semantics on the type of original content, how it's hashed, or what it means to agree with it. Likewise, it doesn't define any recommendation on the semantic validity of an attestation in relation to its recorded time range. As with any kind of recorded agreement, it is generally a good idea for the involved parties to ensure a mutual understanding on what is agreed upon and to what extent. This ERC also allows the agreeing party to amend a previously recorded attestation by redefining the validity time range (including retracting the attestation altogether).","title":"Abstract"},{"location":"Specs/Content-Attestation-Registry-ERC/#motivation","text":"Traditionally, attesting to some kind of content is done through static signatures, e.g. a base64-encoded embedded RSA signature or a PGP signature. As for the smart contract world, hashes are often used in functions to certify content approval but no stable interface has been defined. This EIP is an attempt to homogenize a common interface for agreement that interoperable contract-based and web-based applications may start benefitting from. Also, traditional signatures, in order to be retracted or amended, need to be put in context of Certificate Revocation Lists (CRLs) or similar mechanisms. This EIP attempts to leverage blockchain technology to remove the need for such centralized databases.","title":"Motivation"},{"location":"Specs/Content-Attestation-Registry-ERC/#definitions","text":"Attester The attester of a given content is any entity, represented by an Ethereum address, that records its agreement with that content. Attestation In this specification, an attestation is defined as a (start time, end time) tuple that represents the time range during which a content is agreed upon by a specific attester. Verifier The verifier of an attestation is an entity going through the process of reading an attestation for a given content and making conclusions on whether to trust that content.","title":"Definitions"},{"location":"Specs/Content-Attestation-Registry-ERC/#specification","text":"The general idea of this EIP is that attesting a given content is equivalent to attesting a hash of that content, as long as the hashing function is known by the attester and the verifier. An attestation is recorded as an (iat, exp) tuple, where iat (\"issued at\") is the time the attestation starts to be valid, and exp (\"expires\") is the time after which the attestation is no longer valid. Note the special meaning of the following values: iat == 0 means the attester is NOT currently attesting to that content. In this case, the value of exp is irrelevant. Per Solidity rules, this is the initial value for any attestation. Its intended usage inside the attest() function is to explicitly revoke an existing (i.e. non-zero iat ) attestation. exp == 0 means the attester is not currently placing any expiration time on the attestation. Just like any other value, a value of 0 may be amended later if the attester decides so. This EIP defines the following functions: attest Used in a transaction to record an (iat, exp) attestation of a given hash. function attest(bytes32 hash, uint iat, uint exp) public; attestations Used to read the most recent attestation, if any, of a given hash , recorded by a given attester . Its return value is an (iat, exp) tuple. function attestations(bytes32 hash, address attester) public; This EIP defines the following event: Verified This event is emitted everytime a hash is attested or revoked by an attester and contains the iat and exp times of the attestation. A value of 0 for iat means any previous attestation is being revoked. The event may be emitted with any values for iat and exp , including values equal to the previous ones (for example an already revoked attestation may be revoked again, or an attestation may be attested again with the same values). event Verified(bytes32 indexed hash, address attester, uint iat, uint exp);","title":"Specification"},{"location":"Specs/Content-Attestation-Registry-ERC/#note-about-validity-times","text":"The validity time range is a mere indication by the attester. This EIP does not define what policy should be applied by verifying software or people with respect to current time. Here are a few real-life policy examples: Safe policy . Some verifiers might decide that an attestation is only acceptable if the expiration time is at least 6 months in the future. Flexible policy . Some verifiers might leave a tolerance window during which they still accept an expired attestation. Strict policy . Some verifiers might only accept an attestation during the attestation time range. Some verifiers might apply more complex policies, e.g. where the tolerance depends on the identity of the attester, on the content, on the actual transaction time of the attestation, on the existence of previous attestations, etc.","title":"Note about validity times"},{"location":"Specs/Content-Attestation-Registry-ERC/#rationale","text":"","title":"Rationale"},{"location":"Specs/Content-Attestation-Registry-ERC/#storing-validity-times-on-chain-vs-off-chain","text":"Information stored on a blockchain is both public and permanent, which makes it a crucial decision to decide what to store and what not to store. For this reason, a balance should always be seeked between privacy and usefulness. Specifically, the decision to include validity times on chain rather than in the original content is a result of that subjective balance: Including validity times means leaking out information allowing to suspect or discard specific contents for a given hash. For example, time ranges of 3 weeks might give up certain types of documents, and exclude e.g. passports. Leaving validity times off-chain (typically in the original document) might not work very well for some types of documents where the issuer and the attester are separate entities and the attester doesn't have the liberty to emit an \"attestation document\" containing validity times. This specification allows verifiers to store date information on-chain. However, the attester and the verifier are always free to use any non-zero value in the (iat, exp) tuple and maintain date information off-chain instead.","title":"Storing validity times on-chain vs. off-chain"},{"location":"Specs/Content-Attestation-Registry-ERC/#attesting-hashes-vs-plain-data","text":"To follow best practices, it was deemed equally secure, cheaper, and most respectful to privacy to record fixed-length bytes32 data rather than actual content.","title":"Attesting hashes vs. plain data"},{"location":"Specs/Content-Attestation-Registry-ERC/#backwards-compatibility","text":"This EIP doesn't introduce any known backwards compatibility issues.","title":"Backwards Compatibility"},{"location":"Specs/Content-Attestation-Registry-ERC/#implementation","text":"An implementation may be found here .","title":"Implementation"},{"location":"Specs/Content-Attestation-Registry-ERC/#copyright","text":"Copyright and related rights waived via CC0 .","title":"Copyright"},{"location":"Specs/Credential-Status-ERC721/","text":"Introduction The Verifiable Credential Data Model includes a credentialStatus attribute for credentials. The data model doesn't define an approach for credential statuses, but rather allows different implementations to coexist depending on the type attribute of the credentialStatus object. This document specifies a credential status type called \" ERC721 \", which allows a verifier to query on an Ethereum network the current owner of a Verifiable Credential. A verifiable credential with an ERC721 status behaves as a non-fungible token and as such be collected and transferred between users. Specification credentialStatus Inside the verifiable credential, the following fields are to be used inside the credentialStatus object: type The status type, as defined in the Verifiable Credentials specification. The value MUST be \"ERC721\" . contractAddress A string containing the hexadecimal Ethereum address of the ERC721-compliant smart contract. For example: \"0x123f681646d4a755815f9cb19e1acc8565a0c2ac\" . networkId A string containing the hexadecimal NetworkId of the Ethereum network where the contract is deployed. In order to be able to check status, the verifier must have read access to a node running on that network. Token ID The token ID of a given Verifiable Credential is the SHA256 hash of the credential. Status validation As stated in the VC data model , a verifier may decide to apply their own rules on the status of a credential. In the case of an ERC721 status, some of the rules might include: - Token ID must exist inside the smart contract, i.e. the token hasn't been destroyed. - Current owner must be in a green list of addresses. - Current owner must not be in a red list of addresses. - etc. Example use cases Check current owner or transfer ownership: When buying a piece of artwork or during customs inspection When renting a house or flat from its legitimate owner. Same for buying. When traveling with animals, at the customs. As part of a pet's pedigree. Package tracking: Passing a package from one intermediate to the next. Controlling current responsibility. Production tracking from fabrication to final consumer: Precious metals with certificate, diamonds. Medicine Food industry (e.g. palm oil). As a traffic police officer, checking property title of a vehicle. Privacy considerations Personally-identifiable information Since a hash of the whole credential is stored on the blockchain, issuers should take care of not using ERC721 tracking on credentials that contain personally-identifiable information (PII). TODO Other privacy considerations? Integration notes Identification of owners In ERC721, the owner of a token is an Ethereum address, which makes it a good fit for on-chain use cases such as transfer or identification of owners by other contracts. However, verifiable credentials are typically used in contexts where individuals or organizations are identified by different, off-chain identifiers, such as DIDs or other types of identifiers. This specification doesn't define a mapping between Ethereum addresses and off-chain identifiers. Depending on the use cases, it would be useful to define ways to link an Ethereum address to a subject.","title":"Introduction"},{"location":"Specs/Credential-Status-ERC721/#introduction","text":"The Verifiable Credential Data Model includes a credentialStatus attribute for credentials. The data model doesn't define an approach for credential statuses, but rather allows different implementations to coexist depending on the type attribute of the credentialStatus object. This document specifies a credential status type called \" ERC721 \", which allows a verifier to query on an Ethereum network the current owner of a Verifiable Credential. A verifiable credential with an ERC721 status behaves as a non-fungible token and as such be collected and transferred between users.","title":"Introduction"},{"location":"Specs/Credential-Status-ERC721/#specification","text":"","title":"Specification"},{"location":"Specs/Credential-Status-ERC721/#credentialstatus","text":"Inside the verifiable credential, the following fields are to be used inside the credentialStatus object: type The status type, as defined in the Verifiable Credentials specification. The value MUST be \"ERC721\" . contractAddress A string containing the hexadecimal Ethereum address of the ERC721-compliant smart contract. For example: \"0x123f681646d4a755815f9cb19e1acc8565a0c2ac\" . networkId A string containing the hexadecimal NetworkId of the Ethereum network where the contract is deployed. In order to be able to check status, the verifier must have read access to a node running on that network.","title":"credentialStatus"},{"location":"Specs/Credential-Status-ERC721/#token-id","text":"The token ID of a given Verifiable Credential is the SHA256 hash of the credential.","title":"Token ID"},{"location":"Specs/Credential-Status-ERC721/#status-validation","text":"As stated in the VC data model , a verifier may decide to apply their own rules on the status of a credential. In the case of an ERC721 status, some of the rules might include: - Token ID must exist inside the smart contract, i.e. the token hasn't been destroyed. - Current owner must be in a green list of addresses. - Current owner must not be in a red list of addresses. - etc.","title":"Status validation"},{"location":"Specs/Credential-Status-ERC721/#example-use-cases","text":"Check current owner or transfer ownership: When buying a piece of artwork or during customs inspection When renting a house or flat from its legitimate owner. Same for buying. When traveling with animals, at the customs. As part of a pet's pedigree. Package tracking: Passing a package from one intermediate to the next. Controlling current responsibility. Production tracking from fabrication to final consumer: Precious metals with certificate, diamonds. Medicine Food industry (e.g. palm oil). As a traffic police officer, checking property title of a vehicle.","title":"Example use cases"},{"location":"Specs/Credential-Status-ERC721/#privacy-considerations","text":"","title":"Privacy considerations"},{"location":"Specs/Credential-Status-ERC721/#personally-identifiable-information","text":"Since a hash of the whole credential is stored on the blockchain, issuers should take care of not using ERC721 tracking on credentials that contain personally-identifiable information (PII).","title":"Personally-identifiable information"},{"location":"Specs/Credential-Status-ERC721/#todo","text":"Other privacy considerations?","title":"TODO"},{"location":"Specs/Credential-Status-ERC721/#integration-notes","text":"","title":"Integration notes"},{"location":"Specs/Credential-Status-ERC721/#identification-of-owners","text":"In ERC721, the owner of a token is an Ethereum address, which makes it a good fit for on-chain use cases such as transfer or identification of owners by other contracts. However, verifiable credentials are typically used in contexts where individuals or organizations are identified by different, off-chain identifiers, such as DIDs or other types of identifiers. This specification doesn't define a mapping between Ethereum addresses and off-chain identifiers. Depending on the use cases, it would be useful to define ways to link an Ethereum address to a subject.","title":"Identification of owners"},{"location":"Specs/DIDConnect/","text":"Now you can find the DIDConnect draft specification on Github. We moved it there to let anyone contribute to the specification or ask questions. Please update your bookmarks as this page will disappear eventually.","title":"DIDConnect"},{"location":"Specs/Ethereum-Attestation-Registry-Proof-Type/","text":"Ethereum Attestation Registry Proof Type Abstract This document introduces a new embedded proof type for Verifiable Credentials and Verifiable Presentations, as described in Verifiable Credentials Data Model 's \"Proofs\" section , currently published by the W3C Credentials Community Group. Status of this Document This specification is an unofficial draft. It is provided as a reference for people and organisations who wish to implement Ethereum-based proofs. Introduction The Verifiable Credentials specification describes a modular mechanism for declaring how a given credential must be verified. This specification introduces a new type of proof called \"EthereumAttestationRegistry2019\". This type of proof is based on a trusted smart contract deployed on an Ethereum blockchain accessible by the verifier. Verification of a credential containing this type of proof is done by calls a specific function to the smart contract. This document extends the Verifiable Credentials specification and assumes that the terminology and concepts of that specification are known. Specification An \"Ethereum attestation registry (2019)\" proof is represented by an object contained in the \"proof\" section of a Verifiable Credential. As such, it is considered an \"embedded proof\". It must contain the following attributes: type The proof type, as defined in the Verifiable Credentials specification. The value MUST be `\"EthereumAttestationRegistry2019\"`. contractAddress A string containing the hexadecimal Ethereum address of the smart contract that allows the verification of the credential. For example: `\"0x123f681646d4a755815f9cb19e1acc8565a0c2ac\"`. That contract must implement **EIP-XXX (to be defined): Content Attestation Registry**. networkId A string containing the hexadecimal NetworkId of the Ethereum network where the contract is deployed. In order to be able to verify the credential, the verifier must have read access to a node running on that network. For a proof to be valid, it MUST be possible to determine an Ethereum address from the \"issuer\" attribute. For example, the \"ev\" DID method allows to determine the Ethereum address from a DID. Example The following example shows a Verifiable Credential with an Ethereum Attestation Registry proof. { \"@type\": \"VerifiableCredential\", \"@context\": \"https://schema.org\", \"credentialSubject\": { \"@id\": \"did:example:abcd\", \"name\": \"John Doe\", \"birthdate\": \"2018-01-01\" }, \"issuer\": \"did:ev:2uukHPBYMjdZPkg4p5ZjipKHzkaXLr4T5ut\", \"proof\": { \"type\": \"EthereumAttestationRegistry2019\", \"contractAddress\": \"0x123f681646d4a755815f9cb19e1acc8565a0c2ac\", \"networkId\": \"0x19\" } } Proof Generation Method The following steps MUST be applied by a credential's issuer in order to generate an Ethereum Attestation Registry proof of the credential: Create the proof object as defined in previous sections and add it to the credential as a proof attribute. If proof already exists, ensure it becomes an array containing previous values + the new object. At this point, the issuer MAY distribute the credential. However, it won't be possible to verify the proof until the rest of the steps are applied, so it is RECOMMENDED to wait until the end of the proof generation to distribute the credential. Compute the credential's hash: Temporarily strip the whole \"proof\" attribute from the credential, even if it contains multiple proofs. Serialize the resulting object as a string. TODO: Describe the serialization method (it must be deterministic). Compute the SHA256 hash of the string. Determine the Ethereum address corresponding to the issuer's URI. Decide on the validity timerange of the attestation in the form of a integer couple (iat, exp) , where iat is the start date and exp is the expiration date. Decide on the Ethereum network and smart contract to be used for storing the attestation. Send a transaction to the Ethereum network and smart contract containing a call to the attest(bytes32 hash, uint iat, uint exp) function, where hash , iat and exp are the values computed above. Keep and distribute the resulting credential. Proof Revocation Method This proof type allows for an already-emitted credential to be revoked by its original issuer. The following steps MUST be applied by the credential's issuer in order to revoke an Ethereum Attestation Registry proof: Compute the credential's hash: Temporarily strip the whole \"proof\" attribute from the credential, even if it contains multiple proofs. Serialize the resulting object as a string. TODO: Describe the serialization method (it must be deterministic). Compute the SHA256 hash of the string. Determine the Ethereum address corresponding to the issuer's URI. Send a transaction to the Ethereum network and smart contract listed in the proof to be revoked, containing a call to the attest(bytes32 hash, 0, 0) function, where hash is the credential's hash. Note that no further action is required, since the attestation registry will be updated as soon as the transaction goes through. The attestation registry will also notify interested parties through an Ethereum event that the proof is no longer valid. Proof Verification Method The following steps MUST be applied by a credential's verifier in order to verify an Ethereum Attestation Registry proof of the credential: Compute the credential's hash: Temporarily strip the whole \"proof\" attribute from the credential, even if it contains multiple proofs. Serialize the resulting object as a string. TODO: Describe the serialization method (it must be deterministic). Compute the SHA256 hash of the string. Determine the Ethereum address corresponding to the issuer's URI. Call the attestations(hash, issuer) function of the smart contract listed in the proof, where hash is the credential's hash and issuer is issuer's Ethereum address and store the returned value couple as (iat, exp) . Those are the start date and end date, respectively, specified by the issuer when signing the credential. Verify that the time range is acceptable. The following two conditions below SHOULD both be verified for the credential to be considered valid. However, the verifier MAY apply a different policy if the use case justifies it. iat is not 0 and is lower than the time of the verification. exp is 0 or is higher than the time of the verification. Performance Considerations With this proof type, an Ethereum transaction must be executed for each new attestation. This specification should be improved in the future to allow more scalable approaches.","title":"Ethereum Attestation Registry Proof Type"},{"location":"Specs/Ethereum-Attestation-Registry-Proof-Type/#ethereum-attestation-registry-proof-type","text":"","title":"Ethereum Attestation Registry Proof Type"},{"location":"Specs/Ethereum-Attestation-Registry-Proof-Type/#abstract","text":"This document introduces a new embedded proof type for Verifiable Credentials and Verifiable Presentations, as described in Verifiable Credentials Data Model 's \"Proofs\" section , currently published by the W3C Credentials Community Group.","title":"Abstract"},{"location":"Specs/Ethereum-Attestation-Registry-Proof-Type/#status-of-this-document","text":"This specification is an unofficial draft. It is provided as a reference for people and organisations who wish to implement Ethereum-based proofs.","title":"Status of this Document"},{"location":"Specs/Ethereum-Attestation-Registry-Proof-Type/#introduction","text":"The Verifiable Credentials specification describes a modular mechanism for declaring how a given credential must be verified. This specification introduces a new type of proof called \"EthereumAttestationRegistry2019\". This type of proof is based on a trusted smart contract deployed on an Ethereum blockchain accessible by the verifier. Verification of a credential containing this type of proof is done by calls a specific function to the smart contract. This document extends the Verifiable Credentials specification and assumes that the terminology and concepts of that specification are known.","title":"Introduction"},{"location":"Specs/Ethereum-Attestation-Registry-Proof-Type/#specification","text":"An \"Ethereum attestation registry (2019)\" proof is represented by an object contained in the \"proof\" section of a Verifiable Credential. As such, it is considered an \"embedded proof\". It must contain the following attributes: type The proof type, as defined in the Verifiable Credentials specification. The value MUST be `\"EthereumAttestationRegistry2019\"`. contractAddress A string containing the hexadecimal Ethereum address of the smart contract that allows the verification of the credential. For example: `\"0x123f681646d4a755815f9cb19e1acc8565a0c2ac\"`. That contract must implement **EIP-XXX (to be defined): Content Attestation Registry**. networkId A string containing the hexadecimal NetworkId of the Ethereum network where the contract is deployed. In order to be able to verify the credential, the verifier must have read access to a node running on that network. For a proof to be valid, it MUST be possible to determine an Ethereum address from the \"issuer\" attribute. For example, the \"ev\" DID method allows to determine the Ethereum address from a DID.","title":"Specification"},{"location":"Specs/Ethereum-Attestation-Registry-Proof-Type/#example","text":"The following example shows a Verifiable Credential with an Ethereum Attestation Registry proof. { \"@type\": \"VerifiableCredential\", \"@context\": \"https://schema.org\", \"credentialSubject\": { \"@id\": \"did:example:abcd\", \"name\": \"John Doe\", \"birthdate\": \"2018-01-01\" }, \"issuer\": \"did:ev:2uukHPBYMjdZPkg4p5ZjipKHzkaXLr4T5ut\", \"proof\": { \"type\": \"EthereumAttestationRegistry2019\", \"contractAddress\": \"0x123f681646d4a755815f9cb19e1acc8565a0c2ac\", \"networkId\": \"0x19\" } }","title":"Example"},{"location":"Specs/Ethereum-Attestation-Registry-Proof-Type/#proof-generation-method","text":"The following steps MUST be applied by a credential's issuer in order to generate an Ethereum Attestation Registry proof of the credential: Create the proof object as defined in previous sections and add it to the credential as a proof attribute. If proof already exists, ensure it becomes an array containing previous values + the new object. At this point, the issuer MAY distribute the credential. However, it won't be possible to verify the proof until the rest of the steps are applied, so it is RECOMMENDED to wait until the end of the proof generation to distribute the credential. Compute the credential's hash: Temporarily strip the whole \"proof\" attribute from the credential, even if it contains multiple proofs. Serialize the resulting object as a string. TODO: Describe the serialization method (it must be deterministic). Compute the SHA256 hash of the string. Determine the Ethereum address corresponding to the issuer's URI. Decide on the validity timerange of the attestation in the form of a integer couple (iat, exp) , where iat is the start date and exp is the expiration date. Decide on the Ethereum network and smart contract to be used for storing the attestation. Send a transaction to the Ethereum network and smart contract containing a call to the attest(bytes32 hash, uint iat, uint exp) function, where hash , iat and exp are the values computed above. Keep and distribute the resulting credential.","title":"Proof Generation Method"},{"location":"Specs/Ethereum-Attestation-Registry-Proof-Type/#proof-revocation-method","text":"This proof type allows for an already-emitted credential to be revoked by its original issuer. The following steps MUST be applied by the credential's issuer in order to revoke an Ethereum Attestation Registry proof: Compute the credential's hash: Temporarily strip the whole \"proof\" attribute from the credential, even if it contains multiple proofs. Serialize the resulting object as a string. TODO: Describe the serialization method (it must be deterministic). Compute the SHA256 hash of the string. Determine the Ethereum address corresponding to the issuer's URI. Send a transaction to the Ethereum network and smart contract listed in the proof to be revoked, containing a call to the attest(bytes32 hash, 0, 0) function, where hash is the credential's hash. Note that no further action is required, since the attestation registry will be updated as soon as the transaction goes through. The attestation registry will also notify interested parties through an Ethereum event that the proof is no longer valid.","title":"Proof Revocation Method"},{"location":"Specs/Ethereum-Attestation-Registry-Proof-Type/#proof-verification-method","text":"The following steps MUST be applied by a credential's verifier in order to verify an Ethereum Attestation Registry proof of the credential: Compute the credential's hash: Temporarily strip the whole \"proof\" attribute from the credential, even if it contains multiple proofs. Serialize the resulting object as a string. TODO: Describe the serialization method (it must be deterministic). Compute the SHA256 hash of the string. Determine the Ethereum address corresponding to the issuer's URI. Call the attestations(hash, issuer) function of the smart contract listed in the proof, where hash is the credential's hash and issuer is issuer's Ethereum address and store the returned value couple as (iat, exp) . Those are the start date and end date, respectively, specified by the issuer when signing the credential. Verify that the time range is acceptable. The following two conditions below SHOULD both be verified for the credential to be considered valid. However, the verifier MAY apply a different policy if the use case justifies it. iat is not 0 and is lower than the time of the verification. exp is 0 or is higher than the time of the verification.","title":"Proof Verification Method"},{"location":"Specs/Ethereum-Attestation-Registry-Proof-Type/#performance-considerations","text":"With this proof type, an Ethereum transaction must be executed for each new attestation. This specification should be improved in the future to allow more scalable approaches.","title":"Performance Considerations"},{"location":"Specs/Ethereum-Attestation-Registry-with-Intermediate-Hash-Proof-Type/","text":"Ethereum Attestation Registry with Intermediate Hash Proof Type Abstract This document describes an embedded proof type, applicable both for Verifiable Credentials and for Verifiable Presentations, as described in the Verifiable Credentials Data Model 's \"Proofs\" section by the W3C Credentials Community Group. Status of this Document This specification is an unofficial draft. It is provided as a reference for people and organisations who wish to implement Ethereum-based proofs. Introduction The Verifiable Credentials specification describes a modular mechanism for declaring how a given credential must be verified. This specification introduces a new type of embedded proof called \"EthereumAttestationRegistryIntermediateStatus2021\" . This type of proof is based on a trusted smart contract deployed on an Ethereum blockchain accessible by the verifier. Verification of a credential containing this type of proof is done by calls a specific function to the smart contract. This document extends the Verifiable Credentials specification and assumes that the terminology and concepts of that specification are known. Specification An \"EthereumAttestationRegistryIntermediateStatus2021\" proof is represented by an object contained in the \"proof\" section of a Verifiable Credential. As such, per the VC Data Model, it is considered an \"embedded proof\". It must contain the following attributes: type The proof type, as defined in the Verifiable Credentials specification. The value MUST be \"EthereumAttestationRegistryIntermediateStatus2021\" . contractAddress A string containing the hexadecimal Ethereum address of the smart contract that allows the verification of the credential. For example: \"0x123f681646d4a755815f9cb19e1acc8565a0c2ac\" . That contract must implement **EIP-XXX (to be defined): Content Attestation Registry**. networkId A string containing the hexadecimal NetworkId of the Ethereum network where the contract is deployed. In order to be able to verify the credential, the verifier must have read access to a node running on that network. This proof type requires the DID document of the issuer's DID to contain an ethereumAddress entry. Example { \"@type\": \"VerifiableCredential\", \"@context\": \"http://schema.org\", \"credentialSubject\": { \"@id\": \"did:example:abcd\", \"name\": \"John Doe\", \"birthdate\": \"2018-01-01\" }, \"issuer\": \"did:gid:2uukHPBYMjdZPkg4p5ZjipKHzkaXLr4T5ut\", \"proof\": { \"type\": \"EthereumAttestationRegistryIntermediateStatus2021\", \"contractAddress\": \"0x123f681646d4a755815f9cb19e1acc8565a0c2ac\", \"networkId\": \"0x19\" } } Hash calculation method This proof type involves 2 different hashes per credential: Attestation Hash and Revocation Hash , respectively written on the Ethereum newtwork when the credential is issued and (optionally) revoked. The following steps MUST be applied to generate either hash. Step 1: Calculate the credential's hash. If present, temporarily strip the whole \"proof\" attribute from the credential, even if it contains multiple proofs. Serialize the resulting object as a string. TODO: Describe the serialization method (it must be deterministic). The SHA256 hash of the string is the credential's hash. Step 2: Calculate the final hash. Create the following object: json { \"hash\": <credential's hash in hexadecimal>, \"status\": \"Valid\" | \"Revoked\" } Serialize the object as a string. TODO: Describe the serialization method (it must be deterministic). The SHA256 hash of the string is the final hash (i.e. either Attestation Hash or Revocation Hash depending on the value of status ). Proof Generation Method The following steps MUST be applied by a credential's issuer in order to generate an Ethereum Attestation Registry proof of the credential: Step 1: Calculate Attestation Hash (see above). Step 2: Send the Ethereum transaction. Decide on the Ethereum network and the registry smart contract to be used. On that Ethereum network, make a call to the registry smart contract containing a call to the verify(bytes32 hash, uint iat, uint exp) function, where hash is the Attestation Hash. Good values for iat and exp are the current time and 0 respectively, but you can use different values or make subsequent calls to the contract as needed. See ERC for details. The call to the registry smart contract must be done from an ethereumAddress present in the issuer's DID Document. Create the proof object. Use the original credential (i.e. without stripping the proof object ). Update the credential with the new proof object (see Specification section above). Proof Revocation Method This proof type allows for an issued credential to be revoked by the issuer before its expiration date. Step 1: Calculate Revocation Hash Step 2: Send the Ethereum transaction Use the contract address and network listed in the proof object. Same recommendations as for proof generation, this time using the Revocation Hash. Proof Verification Method To verify the proof, the hashes must be looked up on the registry smart contract. A credential is deemed valid if the Attestation Hash is valid and the Revocation Hash is not valid. The overall verification strategy is the following: Look up the Verification Hash. If it is found, the credential is not valid. Otherwise, look up the Attestation Hash. If it is found, the credential is valid. Otherwise, the credential is not valid. The following steps MUST be applied to look up either hash: Use the contract address and network listed in the proof object. Call the verifications(bytes32 hash, address issuer) function, where: hash is the hash to verify. issuer is the ethereumAddress of the issuer's DID, read from the DID Document. The function returns an (iat, exp) pair. The hash is found if the following conditions are met: iat is not 0 and is lower than the time of the verification. exp is 0 or is higher than the time of the verification. Performance Considerations With this proof type, an Ethereum transaction must be executed for each new attestation. This specification should be improved in the future to allow more scalable approaches.","title":"Ethereum Attestation Registry with Intermediate Hash Proof Type"},{"location":"Specs/Ethereum-Attestation-Registry-with-Intermediate-Hash-Proof-Type/#ethereum-attestation-registry-with-intermediate-hash-proof-type","text":"","title":"Ethereum Attestation Registry with Intermediate Hash Proof Type"},{"location":"Specs/Ethereum-Attestation-Registry-with-Intermediate-Hash-Proof-Type/#abstract","text":"This document describes an embedded proof type, applicable both for Verifiable Credentials and for Verifiable Presentations, as described in the Verifiable Credentials Data Model 's \"Proofs\" section by the W3C Credentials Community Group.","title":"Abstract"},{"location":"Specs/Ethereum-Attestation-Registry-with-Intermediate-Hash-Proof-Type/#status-of-this-document","text":"This specification is an unofficial draft. It is provided as a reference for people and organisations who wish to implement Ethereum-based proofs.","title":"Status of this Document"},{"location":"Specs/Ethereum-Attestation-Registry-with-Intermediate-Hash-Proof-Type/#introduction","text":"The Verifiable Credentials specification describes a modular mechanism for declaring how a given credential must be verified. This specification introduces a new type of embedded proof called \"EthereumAttestationRegistryIntermediateStatus2021\" . This type of proof is based on a trusted smart contract deployed on an Ethereum blockchain accessible by the verifier. Verification of a credential containing this type of proof is done by calls a specific function to the smart contract. This document extends the Verifiable Credentials specification and assumes that the terminology and concepts of that specification are known.","title":"Introduction"},{"location":"Specs/Ethereum-Attestation-Registry-with-Intermediate-Hash-Proof-Type/#specification","text":"An \"EthereumAttestationRegistryIntermediateStatus2021\" proof is represented by an object contained in the \"proof\" section of a Verifiable Credential. As such, per the VC Data Model, it is considered an \"embedded proof\". It must contain the following attributes: type The proof type, as defined in the Verifiable Credentials specification. The value MUST be \"EthereumAttestationRegistryIntermediateStatus2021\" . contractAddress A string containing the hexadecimal Ethereum address of the smart contract that allows the verification of the credential. For example: \"0x123f681646d4a755815f9cb19e1acc8565a0c2ac\" . That contract must implement **EIP-XXX (to be defined): Content Attestation Registry**. networkId A string containing the hexadecimal NetworkId of the Ethereum network where the contract is deployed. In order to be able to verify the credential, the verifier must have read access to a node running on that network. This proof type requires the DID document of the issuer's DID to contain an ethereumAddress entry.","title":"Specification"},{"location":"Specs/Ethereum-Attestation-Registry-with-Intermediate-Hash-Proof-Type/#example","text":"{ \"@type\": \"VerifiableCredential\", \"@context\": \"http://schema.org\", \"credentialSubject\": { \"@id\": \"did:example:abcd\", \"name\": \"John Doe\", \"birthdate\": \"2018-01-01\" }, \"issuer\": \"did:gid:2uukHPBYMjdZPkg4p5ZjipKHzkaXLr4T5ut\", \"proof\": { \"type\": \"EthereumAttestationRegistryIntermediateStatus2021\", \"contractAddress\": \"0x123f681646d4a755815f9cb19e1acc8565a0c2ac\", \"networkId\": \"0x19\" } }","title":"Example"},{"location":"Specs/Ethereum-Attestation-Registry-with-Intermediate-Hash-Proof-Type/#hash-calculation-method","text":"This proof type involves 2 different hashes per credential: Attestation Hash and Revocation Hash , respectively written on the Ethereum newtwork when the credential is issued and (optionally) revoked. The following steps MUST be applied to generate either hash. Step 1: Calculate the credential's hash. If present, temporarily strip the whole \"proof\" attribute from the credential, even if it contains multiple proofs. Serialize the resulting object as a string. TODO: Describe the serialization method (it must be deterministic). The SHA256 hash of the string is the credential's hash. Step 2: Calculate the final hash. Create the following object: json { \"hash\": <credential's hash in hexadecimal>, \"status\": \"Valid\" | \"Revoked\" } Serialize the object as a string. TODO: Describe the serialization method (it must be deterministic). The SHA256 hash of the string is the final hash (i.e. either Attestation Hash or Revocation Hash depending on the value of status ).","title":"Hash calculation method"},{"location":"Specs/Ethereum-Attestation-Registry-with-Intermediate-Hash-Proof-Type/#proof-generation-method","text":"The following steps MUST be applied by a credential's issuer in order to generate an Ethereum Attestation Registry proof of the credential: Step 1: Calculate Attestation Hash (see above). Step 2: Send the Ethereum transaction. Decide on the Ethereum network and the registry smart contract to be used. On that Ethereum network, make a call to the registry smart contract containing a call to the verify(bytes32 hash, uint iat, uint exp) function, where hash is the Attestation Hash. Good values for iat and exp are the current time and 0 respectively, but you can use different values or make subsequent calls to the contract as needed. See ERC for details. The call to the registry smart contract must be done from an ethereumAddress present in the issuer's DID Document. Create the proof object. Use the original credential (i.e. without stripping the proof object ). Update the credential with the new proof object (see Specification section above).","title":"Proof Generation Method"},{"location":"Specs/Ethereum-Attestation-Registry-with-Intermediate-Hash-Proof-Type/#proof-revocation-method","text":"This proof type allows for an issued credential to be revoked by the issuer before its expiration date. Step 1: Calculate Revocation Hash Step 2: Send the Ethereum transaction Use the contract address and network listed in the proof object. Same recommendations as for proof generation, this time using the Revocation Hash.","title":"Proof Revocation Method"},{"location":"Specs/Ethereum-Attestation-Registry-with-Intermediate-Hash-Proof-Type/#proof-verification-method","text":"To verify the proof, the hashes must be looked up on the registry smart contract. A credential is deemed valid if the Attestation Hash is valid and the Revocation Hash is not valid. The overall verification strategy is the following: Look up the Verification Hash. If it is found, the credential is not valid. Otherwise, look up the Attestation Hash. If it is found, the credential is valid. Otherwise, the credential is not valid. The following steps MUST be applied to look up either hash: Use the contract address and network listed in the proof object. Call the verifications(bytes32 hash, address issuer) function, where: hash is the hash to verify. issuer is the ethereumAddress of the issuer's DID, read from the DID Document. The function returns an (iat, exp) pair. The hash is found if the following conditions are met: iat is not 0 and is lower than the time of the verification. exp is 0 or is higher than the time of the verification.","title":"Proof Verification Method"},{"location":"Specs/Ethereum-Attestation-Registry-with-Intermediate-Hash-Proof-Type/#performance-considerations","text":"With this proof type, an Ethereum transaction must be executed for each new attestation. This specification should be improved in the future to allow more scalable approaches.","title":"Performance Considerations"},{"location":"Specs/GID-DID-Method/","text":"Now you can find the EV DID method specification on Github. We moved it there to let anyone contribute to the specification or ask questions. Please update your bookmarks as this page will disappear eventually.","title":"GID DID Method"},{"location":"Specs/Proxy-Contract-ERC/","text":"eip: <to be assigned> title: ERC: Identity Proxy Contract author: David Ammouial (@davux) <dammouia@everis.com> status: Draft type: Standards Track category: ERC created: 2019-06-04 Simple Summary Identity contract Abstract This ERC describes the interface used for identity management: creation of an identity, update of information related to an identity, and action on behalf of an identity. Motivation There is a need to standardize the interface for contract-based digital identities to be used, so as to allow for interoperability between implementations. Definitions Owner The owner of an identity (i.e. Proxy contract) is an Ethereum address recognized by the Proxy contract to originate transactions that the Proxy contract will forward. While the address of a Proxy contract is permanent, owners may be added and removed as needed. Specification This EIP defines an interface called Proxy , which provides the following functions: constructor The constructor is used to instantiate a new identity (i.e. Proxy contract). It takes a firstOwner address of that proxy. constructor(firstOwner) public forward Used to instruct the smart contract to execute a given function (in the form of its bytecode data ) and/or transfer a certain value of ethers to a given destination smart contract. function forward(address destination, uint value, bytes data) public; isOwner Returns whether a given address is allowed to execute forward on the smart contract. function isOwner(address) public returns (bool); addOwner function addOwner(address newOwner) public; Used to add a newOwner address as an owner of the smart contract. renounce Used to give up ownership of the smart contract. function renounce() public; In addition, this EIP defines the following events: OwnerAdded This event is emitted everytime a newOwner address is added to the contract. OwnerAdded(address indexed newOwner) OwnerRemoved This event is emitted everytime a formerOwner address is removed from the contract. OwnerRemoved(address indexed formerOwner) Rationale For digital identity to be self-sovereign, it needs to be able to rely on a trusted, decentralized backbone. Ethereum blockchain is a satisfying component for that requisite. Backwards Compatibility This EIP doesn't introduce any known backwards compatibility issues. However, it does a similar job as other ERCs such as ERC-725 and others, and there are plans to integrate the most recent developments into this EIP. Implementation KayTrust Provider web application and KayTrust Wallet mobile application provide an implementation of the Proxy contract. Copyright Copyright and related rights waived via CC0 .","title":"Proxy Contract ERC"},{"location":"Specs/Proxy-Contract-ERC/#simple-summary","text":"Identity contract","title":"Simple Summary"},{"location":"Specs/Proxy-Contract-ERC/#abstract","text":"This ERC describes the interface used for identity management: creation of an identity, update of information related to an identity, and action on behalf of an identity.","title":"Abstract"},{"location":"Specs/Proxy-Contract-ERC/#motivation","text":"There is a need to standardize the interface for contract-based digital identities to be used, so as to allow for interoperability between implementations.","title":"Motivation"},{"location":"Specs/Proxy-Contract-ERC/#definitions","text":"Owner The owner of an identity (i.e. Proxy contract) is an Ethereum address recognized by the Proxy contract to originate transactions that the Proxy contract will forward. While the address of a Proxy contract is permanent, owners may be added and removed as needed.","title":"Definitions"},{"location":"Specs/Proxy-Contract-ERC/#specification","text":"This EIP defines an interface called Proxy , which provides the following functions: constructor The constructor is used to instantiate a new identity (i.e. Proxy contract). It takes a firstOwner address of that proxy. constructor(firstOwner) public forward Used to instruct the smart contract to execute a given function (in the form of its bytecode data ) and/or transfer a certain value of ethers to a given destination smart contract. function forward(address destination, uint value, bytes data) public; isOwner Returns whether a given address is allowed to execute forward on the smart contract. function isOwner(address) public returns (bool); addOwner function addOwner(address newOwner) public; Used to add a newOwner address as an owner of the smart contract. renounce Used to give up ownership of the smart contract. function renounce() public; In addition, this EIP defines the following events: OwnerAdded This event is emitted everytime a newOwner address is added to the contract. OwnerAdded(address indexed newOwner) OwnerRemoved This event is emitted everytime a formerOwner address is removed from the contract. OwnerRemoved(address indexed formerOwner)","title":"Specification"},{"location":"Specs/Proxy-Contract-ERC/#rationale","text":"For digital identity to be self-sovereign, it needs to be able to rely on a trusted, decentralized backbone. Ethereum blockchain is a satisfying component for that requisite.","title":"Rationale"},{"location":"Specs/Proxy-Contract-ERC/#backwards-compatibility","text":"This EIP doesn't introduce any known backwards compatibility issues. However, it does a similar job as other ERCs such as ERC-725 and others, and there are plans to integrate the most recent developments into this EIP.","title":"Backwards Compatibility"},{"location":"Specs/Proxy-Contract-ERC/#implementation","text":"KayTrust Provider web application and KayTrust Wallet mobile application provide an implementation of the Proxy contract.","title":"Implementation"},{"location":"Specs/Proxy-Contract-ERC/#copyright","text":"Copyright and related rights waived via CC0 .","title":"Copyright"},{"location":"Specs/Trusted-Credentials/","text":"Now you can find the Trusted Credentials schema on Github. We moved it there to let anyone contribute to the specification or ask questions. Please update your bookmarks as this page will disappear eventually.","title":"Trusted Credentials"},{"location":"Tutorials/java-sdk/","text":"Kaytrust Core SDK Introduction Kaytrust Core SDK is a library built on java, it allows developers to interact with the Lacchain Ethereum Network in order to perform actions related to the creation and validation of Identities and verifiable credentials. Key concepts and considerations public/private keys used here are based on elliptic curve cryptography. did: Decentralized Identifier. A a new type of identifier for verifiable, decentralized digital identity. Find the W3C definition here Verifiable credential: a tamper-evident credential that has authorship that can be cryptographically verified. Verifiable credentials can be used to build verifiable presentations, which can also be cryptographically verified. The claims in a credential can be about different subjects. Reference: https://www.w3.org/TR/vc-imp-guide/ Examples: https://www.w3.org/TR/vc-imp-guide/#example-1-a-subject-disputes-a-credential Address: Is the short descriptor, composed with 40 hexadecimal characters, which is derived from the ECC public key. Capability: This an authorization capability which is set in the identity Manager smart contract. Capabilities associate granted permissions over a proxy address for a certain or indefinitely time. There are four defined capalibities (forward, devicemanager, admin and auth) Device authorization validation: Means verifying that a certain device(identified by a public key) has a capability to perform some action related to the Proxy contract. Identity Provider: This is the entity that helps users create their identities and more importantly helps to recover the user identity in case a user is not able to access its identity. Issue a credential: The process by which an issuer emits a verifiable credential on behalf of a user, the proof of validity is a signed range of time in which a hash (that represents a verifiable credential) is made available on a smart contract (Verification Registry). Requisites Java 8 Repository URL link here What can I do with this SDK? Identity creation for a user: This functionality can be in two steps: An Identity Provider creates an identity, the SDK goes to the blockchain and creates a new identity for you. As a result a decentralized identity is returned. Lets see it in a diagram: The provider associates the user's device address with the did obtained in the previous step. Note : Adding another device follows the exact process, but the did (that contains the smart contract proxy address) must be specified. In a later example this will be explained with an example. Device Autorization Validation: Check what a device can do (these are known as capabilities given to different devices). Issue a Verifiable Credential: Lets see what is the flow when this sdk generates a verifiable credential Check for a verifiable credential validity Examples You can also find all examples in src/test into the packages: id.kaytrust.core.identity.ethereum id.kaytrust.core.verifiableCredential.ethereum Assumptions: A new user wants to deploy a new contract (Proxy contract) that represents its identity, the user will do this through the existing Identity Manager contract, it will create the Proxy and make the association between the user'\u015b device and the Proxy Contract. Previous setting Setting an Identity Manager instance EthereumIdentityManager identityManager; String rpcConnection = \"http://eth-lacchain.kaytrust.id\"; //The ethereum node to access the Lacchain Network String IdentityManagerContractAddress = \"0xa6b4540a2bfbe8663caa78027c83d0dcb1b7c837\"; //This is the existing IdentityManager contract address String providerPrivateKey = \"0x9eb5a43839e8ff36fcdaed658136c51623be3af7de304d1c9181a6be9fac0863\"; //Provider private key { identityManager = new EthereumIdentityManagerImpl(); //Sets a new instance of IdentityManager to interact with. try { identityManager.instance(rpcConnection, providerPrivateKey, IdentityManagerContractAddress); } catch (Exception e) { e.printStackTrace(); } } Creating a new Identity with the provider key try{ System.out.println(\"*****************************************************************************\"); System.out.println(\"************************* Create Identity ********************************\"); String did = identityManager.createIdentity(); //Deploys a new Proxy Contract and sets Identity Provider private key // with all capabilities (it allows recovery functionalities) // Now verifying the did is not null boolean isTrue = !did.isEmpty(); System.out.println(\"Created DID: \" + did);//At this point only the identity provider has authorization over the proxy if (isTrue){ System.out.println(\"SUCCESS\"); } assertNotNull(did); }catch(Exception e){ e.printStackTrace(); fail(); } By creating an Identity a new did (decentralized identifier) is returned, this did has been associated with a provider address. At this point only the provider can add devices on behalf of a user. Associating a user's device address to the new proxy contract identity. try { System.out.println(\"*****************************************************************************\"); System.out.println(\"************************* Authorize Device *******************************\"); String devicePublicKey = \"fadb30ab306603e1806e1fbd324cf21aaefb32c8a1f3f4cf701f3eafd17df68e97ec33dd77d7d6e7dc436905dc47f2f3da907e3a3be05cce348d10d51323dd5e\"; identityManager.authorizeDevice(did, devicePublicKey, CapabilityEnum.FORWARD.description()); //Setting forward // capability, between the Proxy and the device, in the IdentityManager contract. System.out.println(\"SUCCESS\"); assertNotNull(did); } catch (Exception e) { System.out.println(\"FAILED\"); e.printStackTrace(); fail(); } Notes: Note that the identity Manager instance has been initialized with a private key that has all permissions over the deployed proxy, that is why it is possible to associate a new device with the Proxy contract. The association process can be repeated \"n\" times to add as many devices as requrired. Identity Validation Now that a new did has been created lets verify if the \"deviceA\" has the \"forward\" capability. Note the some variables which has been previously defined are been reused. try { EthereumIdentityConsumer identityConsumer=new EthereumIdentityConsumerImpl(); identityConsumer.instance(rpcConnection, null, identityManagerContractAddress); boolean isTrue = identityConsumer.isDeviceAuthorized(did, devicePublicKey,CapabilityEnum.FORWARD.description());//you can check other capabilities like FORWARD, AUTH or DEVICE_MANAGER if (isTrue){ System.out.println(\"SUCCESS\"); } assertTrue(isTrue); } catch (Exception e) { e.printStackTrace(); fail(); } Issuing a credential Setting a Subject example class definition: //Setting a Subject example class definition: class CredentialSubject { @SerializedName(\"@id\") String id; String name; String birthDate; } //Defining general variables before executing examples related to credential issuance String issuerPrivateKey; EthereumCredentialIssuer credentialIssuer; { String verificationRegistryContractAddress = \"0x9f8c1e196F5696e014F4d1E4961B92db866BE271\"; credentialIssuer = new EthereumCredentialIssuerImpl(); try { issuerPrivateKey = \"0x9eb5a43839e8ff36fcdaed658136c51623be3af7de304d1c9181a6be9fac0863\"; credentialIssuer.instance(rpcConnection, issuerPrivateKey, verificationRegistryContractAddress); } catch (Exception e) { e.printStackTrace(); } } Issuance process: public void issueCredential() { System.out.println(\"*****************************************************************************\"); System.out.println(\"************************* Credential Issuance *******************************\"); try { String subject = \"{\" + \"\\\"@id\\\":\" + \"\\\"did:ev:cwMLLiMQGm9EaTqzY2k58refSoXdTsYvJ9Znp\\\",\" + \"\\\"name\\\":\\\"John Doe\\\",\" + \"\\\"birthDate\\\":\\\"2018-01-01\\\"}\"; CredentialSubject sc = new Gson().fromJson(subject, CredentialSubject.class); String[] credentialType = { \"VerifiableCredential\", \"MyCustomType\" }; String vc = credentialIssuer.issueCredential(sc, credentialType, null, null, new EthereumAttestation2019Builder(), null); log.info(\"verificationCredential :\\n {} \",vc); if (!vc.isEmpty()){ log.info(\"SUCCESS\"); } assertNotNull(vc); } catch (Exception e) { e.printStackTrace(); fail(); } } Checking for a Verifiable credential validity Previous setting EthereumCredentialValidation credentialValidation; { System.out.println(\"********************** Credential ValidationTest - Previous Setting ****************************\"); credentialValidation = new EthereumCredentialValidationImpl(); try { credentialValidation.instance(rpcConnection, issuerPrivateKey, verificationRegistryContractAddress, new EthereumAttestation2019Builder()); System.out.println(\"Verifiable credential is: \" + vc + \"\\nIssued by \" + (EthereumKeyUtils.getAddressFromPrivateKey(issuerPrivateKey))); } catch (Exception e) { e.printStackTrace(); } } It is time to check if a verifiable credential is valid or not, by checking if an issuer has registered a credential hash on the Verification Registry contract public void credentialCheckingTest() { System.out.println(\"*****************************************************************************\"); System.out.println(\"********************** Credential ValidationTest ****************************\"); try { System.out.println(\"Verifying \" + (EthereumKeyUtils.getAddressFromPrivateKey(issuerPrivateKey)) +\" has emitted the verifiable credential and also the verifiable credential is not expired...\"); //Note that it is not necessary to have the private key but only the issuer address. boolean isValidCredential = credentialValidation.verifyCredential(vc);//returns \"true\" if the verifiable credential is valid; otherwise \"false\"; //in this case we are simply using the verifiable credential that was returned in the previous step. if (isValidCredential){ log.info(\"SUCCESS\"); } assertTrue(isValidCredential); } catch (Exception e) { e.printStackTrace(); fail(); } }","title":"Kaytrust Core SDK"},{"location":"Tutorials/java-sdk/#kaytrust-core-sdk","text":"","title":"Kaytrust Core SDK"},{"location":"Tutorials/java-sdk/#introduction","text":"Kaytrust Core SDK is a library built on java, it allows developers to interact with the Lacchain Ethereum Network in order to perform actions related to the creation and validation of Identities and verifiable credentials.","title":"Introduction"},{"location":"Tutorials/java-sdk/#key-concepts-and-considerations","text":"public/private keys used here are based on elliptic curve cryptography. did: Decentralized Identifier. A a new type of identifier for verifiable, decentralized digital identity. Find the W3C definition here Verifiable credential: a tamper-evident credential that has authorship that can be cryptographically verified. Verifiable credentials can be used to build verifiable presentations, which can also be cryptographically verified. The claims in a credential can be about different subjects. Reference: https://www.w3.org/TR/vc-imp-guide/ Examples: https://www.w3.org/TR/vc-imp-guide/#example-1-a-subject-disputes-a-credential Address: Is the short descriptor, composed with 40 hexadecimal characters, which is derived from the ECC public key. Capability: This an authorization capability which is set in the identity Manager smart contract. Capabilities associate granted permissions over a proxy address for a certain or indefinitely time. There are four defined capalibities (forward, devicemanager, admin and auth) Device authorization validation: Means verifying that a certain device(identified by a public key) has a capability to perform some action related to the Proxy contract. Identity Provider: This is the entity that helps users create their identities and more importantly helps to recover the user identity in case a user is not able to access its identity. Issue a credential: The process by which an issuer emits a verifiable credential on behalf of a user, the proof of validity is a signed range of time in which a hash (that represents a verifiable credential) is made available on a smart contract (Verification Registry).","title":"Key concepts and considerations"},{"location":"Tutorials/java-sdk/#requisites","text":"Java 8","title":"Requisites"},{"location":"Tutorials/java-sdk/#repository-url","text":"link here","title":"Repository URL"},{"location":"Tutorials/java-sdk/#what-can-i-do-with-this-sdk","text":"Identity creation for a user: This functionality can be in two steps: An Identity Provider creates an identity, the SDK goes to the blockchain and creates a new identity for you. As a result a decentralized identity is returned. Lets see it in a diagram: The provider associates the user's device address with the did obtained in the previous step. Note : Adding another device follows the exact process, but the did (that contains the smart contract proxy address) must be specified. In a later example this will be explained with an example. Device Autorization Validation: Check what a device can do (these are known as capabilities given to different devices). Issue a Verifiable Credential: Lets see what is the flow when this sdk generates a verifiable credential Check for a verifiable credential validity","title":"What can I do with this SDK?"},{"location":"Tutorials/java-sdk/#examples","text":"You can also find all examples in src/test into the packages: id.kaytrust.core.identity.ethereum id.kaytrust.core.verifiableCredential.ethereum Assumptions: A new user wants to deploy a new contract (Proxy contract) that represents its identity, the user will do this through the existing Identity Manager contract, it will create the Proxy and make the association between the user'\u015b device and the Proxy Contract.","title":"Examples"},{"location":"Tutorials/java-sdk/#previous-setting","text":"Setting an Identity Manager instance EthereumIdentityManager identityManager; String rpcConnection = \"http://eth-lacchain.kaytrust.id\"; //The ethereum node to access the Lacchain Network String IdentityManagerContractAddress = \"0xa6b4540a2bfbe8663caa78027c83d0dcb1b7c837\"; //This is the existing IdentityManager contract address String providerPrivateKey = \"0x9eb5a43839e8ff36fcdaed658136c51623be3af7de304d1c9181a6be9fac0863\"; //Provider private key { identityManager = new EthereumIdentityManagerImpl(); //Sets a new instance of IdentityManager to interact with. try { identityManager.instance(rpcConnection, providerPrivateKey, IdentityManagerContractAddress); } catch (Exception e) { e.printStackTrace(); } }","title":"Previous setting"},{"location":"Tutorials/java-sdk/#creating-a-new-identity-with-the-provider-key","text":"try{ System.out.println(\"*****************************************************************************\"); System.out.println(\"************************* Create Identity ********************************\"); String did = identityManager.createIdentity(); //Deploys a new Proxy Contract and sets Identity Provider private key // with all capabilities (it allows recovery functionalities) // Now verifying the did is not null boolean isTrue = !did.isEmpty(); System.out.println(\"Created DID: \" + did);//At this point only the identity provider has authorization over the proxy if (isTrue){ System.out.println(\"SUCCESS\"); } assertNotNull(did); }catch(Exception e){ e.printStackTrace(); fail(); } By creating an Identity a new did (decentralized identifier) is returned, this did has been associated with a provider address. At this point only the provider can add devices on behalf of a user. Associating a user's device address to the new proxy contract identity. try { System.out.println(\"*****************************************************************************\"); System.out.println(\"************************* Authorize Device *******************************\"); String devicePublicKey = \"fadb30ab306603e1806e1fbd324cf21aaefb32c8a1f3f4cf701f3eafd17df68e97ec33dd77d7d6e7dc436905dc47f2f3da907e3a3be05cce348d10d51323dd5e\"; identityManager.authorizeDevice(did, devicePublicKey, CapabilityEnum.FORWARD.description()); //Setting forward // capability, between the Proxy and the device, in the IdentityManager contract. System.out.println(\"SUCCESS\"); assertNotNull(did); } catch (Exception e) { System.out.println(\"FAILED\"); e.printStackTrace(); fail(); } Notes: Note that the identity Manager instance has been initialized with a private key that has all permissions over the deployed proxy, that is why it is possible to associate a new device with the Proxy contract. The association process can be repeated \"n\" times to add as many devices as requrired.","title":"Creating a new Identity with the provider key"},{"location":"Tutorials/java-sdk/#identity-validation","text":"Now that a new did has been created lets verify if the \"deviceA\" has the \"forward\" capability. Note the some variables which has been previously defined are been reused. try { EthereumIdentityConsumer identityConsumer=new EthereumIdentityConsumerImpl(); identityConsumer.instance(rpcConnection, null, identityManagerContractAddress); boolean isTrue = identityConsumer.isDeviceAuthorized(did, devicePublicKey,CapabilityEnum.FORWARD.description());//you can check other capabilities like FORWARD, AUTH or DEVICE_MANAGER if (isTrue){ System.out.println(\"SUCCESS\"); } assertTrue(isTrue); } catch (Exception e) { e.printStackTrace(); fail(); }","title":"Identity Validation"},{"location":"Tutorials/java-sdk/#issuing-a-credential","text":"Setting a Subject example class definition: //Setting a Subject example class definition: class CredentialSubject { @SerializedName(\"@id\") String id; String name; String birthDate; } //Defining general variables before executing examples related to credential issuance String issuerPrivateKey; EthereumCredentialIssuer credentialIssuer; { String verificationRegistryContractAddress = \"0x9f8c1e196F5696e014F4d1E4961B92db866BE271\"; credentialIssuer = new EthereumCredentialIssuerImpl(); try { issuerPrivateKey = \"0x9eb5a43839e8ff36fcdaed658136c51623be3af7de304d1c9181a6be9fac0863\"; credentialIssuer.instance(rpcConnection, issuerPrivateKey, verificationRegistryContractAddress); } catch (Exception e) { e.printStackTrace(); } } Issuance process: public void issueCredential() { System.out.println(\"*****************************************************************************\"); System.out.println(\"************************* Credential Issuance *******************************\"); try { String subject = \"{\" + \"\\\"@id\\\":\" + \"\\\"did:ev:cwMLLiMQGm9EaTqzY2k58refSoXdTsYvJ9Znp\\\",\" + \"\\\"name\\\":\\\"John Doe\\\",\" + \"\\\"birthDate\\\":\\\"2018-01-01\\\"}\"; CredentialSubject sc = new Gson().fromJson(subject, CredentialSubject.class); String[] credentialType = { \"VerifiableCredential\", \"MyCustomType\" }; String vc = credentialIssuer.issueCredential(sc, credentialType, null, null, new EthereumAttestation2019Builder(), null); log.info(\"verificationCredential :\\n {} \",vc); if (!vc.isEmpty()){ log.info(\"SUCCESS\"); } assertNotNull(vc); } catch (Exception e) { e.printStackTrace(); fail(); } }","title":"Issuing a credential"},{"location":"Tutorials/java-sdk/#checking-for-a-verifiable-credential-validity","text":"Previous setting EthereumCredentialValidation credentialValidation; { System.out.println(\"********************** Credential ValidationTest - Previous Setting ****************************\"); credentialValidation = new EthereumCredentialValidationImpl(); try { credentialValidation.instance(rpcConnection, issuerPrivateKey, verificationRegistryContractAddress, new EthereumAttestation2019Builder()); System.out.println(\"Verifiable credential is: \" + vc + \"\\nIssued by \" + (EthereumKeyUtils.getAddressFromPrivateKey(issuerPrivateKey))); } catch (Exception e) { e.printStackTrace(); } } It is time to check if a verifiable credential is valid or not, by checking if an issuer has registered a credential hash on the Verification Registry contract public void credentialCheckingTest() { System.out.println(\"*****************************************************************************\"); System.out.println(\"********************** Credential ValidationTest ****************************\"); try { System.out.println(\"Verifying \" + (EthereumKeyUtils.getAddressFromPrivateKey(issuerPrivateKey)) +\" has emitted the verifiable credential and also the verifiable credential is not expired...\"); //Note that it is not necessary to have the private key but only the issuer address. boolean isValidCredential = credentialValidation.verifyCredential(vc);//returns \"true\" if the verifiable credential is valid; otherwise \"false\"; //in this case we are simply using the verifiable credential that was returned in the previous step. if (isValidCredential){ log.info(\"SUCCESS\"); } assertTrue(isValidCredential); } catch (Exception e) { e.printStackTrace(); fail(); } }","title":"Checking for a Verifiable credential validity"}]}